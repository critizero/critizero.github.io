{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-09","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"07-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-09","excerpt":""}],"posts":[{"title":"Reverse writeup","text":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心 题目在这 随便看看在Ubuntu里file得知是64位的文件 运行下试试 看起来就是要找到密码 废话！ 一顿分析用最爱的IDA打开 发现 密码长度为32个字符串 每4位组合成一个int类型的值 判断总共是8个方程 前四个int类型的数异或以后当成rand的种子 工具 python的z3-solver库，linux下的 脚本 前四位（a,b,c,d) 12345678910#!/usr/bin/env pythonfrom z3 import *a = Int('a')b = Int('b')c = Int('c')d = Int('d')solve(b*a-c*d == 0x24CDF2E7C953DA56, 3*c+4*d-b-2*a == 0x17B85F06, 3*a*d-c*b == 0x2E6E497E6415CF3E, 27*b+a-11*d-c == 0x95AE13337) ​ 解出来就得到密码前16位 后四位（e,f,g,h） 按照只要种子一样，得到的随机数数列也是相同的，所以很容易得到它的那些参数，但是这里我踩了个坑 这里随机数要用gdb单步出来 我开始没在Ubuntu里，在Windows下用C语言写的，然后得到的参数根本解不出来。。。 只要把前十六位解出来转换成字符串，再加上16位任意字符，凑成32位的密码，关注得到随机参数时eax的值，记录下来就是了，顺便还能检查一下前十六位有没有解错（解错会有跳转 至于为什么，其实我也不知道大概是因为系统不同吧 12345678910#!/usr/bin/env pythonfrom z3 import *e = Int('e')f = Int('f')g = Int('g')h = Int('h')solve(h*0x27+e*0x16-f-g == 0xE638C96D3, h+e+g*0x2d-f*0x2d == 0xB59F2D0CB, e*0x23+f*0x29-g-h == 0xDCFE88C6D, g*0x24+e-f-h*0xd == 0xC076D98BB) ​ 同样，跑出来就是密码后16位 密码 将32位都跑出来以后，直接转换成字符串，就能得到密码 12345int i;int sum[32]=&#123;0x61,0x6D,0x70,0x6F,0x5A,0x32,0x5A,0x6B,0x4E,0x6E,0x6B,0x31,0x4E,0x48,0x6C,0x33, 0x4E,0x54,0x63,0x30,0x4E,0x54,0x63,0x31,0x5A,0x33,0x4E,0x6F,0x61,0x47,0x46,0x47&#125;;for(i=0;i&lt;32;i++) printf(\"%c\",sum[i]); 结果然后就是激动人心的得到falg的过程了 看来没错了 总结​ 这个题讲真，虽然是很简单的那种题毕竟连我都会，但是那种激动的感觉真的没法用言语说明，就像发现新大陆的感觉，也可能是那种学了这么久能独立写出题的快乐吧","path":"2018/07/09/Reverse/","date":"07-09","excerpt":""},{"title":"Hello World","text":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的 十分感谢 codgician 大佬的无私帮助，%%%%%%% 就跟每个语言的初学者的第一份代码一样 Hello World！Hello world~","path":"2018/07/08/hello-world/","date":"07-08","excerpt":""}]}