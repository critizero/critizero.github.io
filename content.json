{"pages":[{"title":"search","text":"","path":"search/index.html","date":"07-09","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"07-09","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"07-09","excerpt":""}],"posts":[{"title":"magic","text":"这个题调得有点久23333 但是收获很大0v0 题目在此 先看看直接运行有警告（黑客做的东西一个都不能在实体机上打开.jpg 命令行运行试试 看这时间就很有意思啊orz 看来还得获取正确的时间 工具x64dbg &amp; IDA 漫长的调试之路 入口看起来就有点迷 步进以后是各种系统函数的开头ntdll.xxxxxxx开头的各种调用，开始慌了，但是这些应该都是系统调用，主要看的应该是magic.xxxxx这样的才对 然后就每个magic开头的调用都用ida找到对应的地址，分析一波函数，耗费无数时间和头发以后，终于来到一个奇妙的函数sub_402563，用ida看这个函数是这样子的： 这个看起来就很棒啊，看着一地的头发，我不禁陷入沉思：为什么不一开始就搜索字符串。。。 然后看这判断，一看就可以写脚本跑啊，然后 呵呵，摔(╯‵□′)╯︵┻━┻ 对不起我这一地头发！！！ 算了继续。 然后就接着单步，在wp的提醒下，我学会了一边看控制台一边单步，来找到关键函数。。。（我还是太菜了 通过单步发现这个call输出了结果，最终结果是magic.402218输出的，但是ida分析后发现这个函数没有判断，然后就往上找可以找到magic.402268，然后ida打开，这就找到了判断时间的关键函数 很明显，byte_405020是密钥，通过与正确的时作为种子所生成的随机数异或，然后调用另外一个函数sub_4027ED 仔细看可以看出来，Dst是个结构体，大小为12byte，是个有256个结构体的结构体数组，结构体大概长这样 12345struct Dst&#123; BYTE ch; DWORD mem1; DWORD mem2;&#125;; //由于对齐的原因，ch后补了3个空字节，DWORD占4个字节，所以总共是12个字节 对于每个结构体，ch被赋值为相应的异或后的结果，mem1赋值为0x7FFFFFFF，mem2赋值为0，然后就进入下个函数 还可以通过查看栈的位置，发现v2和v1其实分别是Dst[255]的mem1和mem2的值 sub_4026D0就是个对结构体的处理函数，于是就可以总结一哈： 时间在 0x5AFFE78F~0x5B028A8F 之间，并作为随机数种子 通过与一个字符数组的序列进行异或，生成一个结构体数组 结构体数组进行操作，可以得到v1、v2的值 v2的值实际上是Dst[255].mem1，并且应该等于0x700 于是，有了这些，就可以愉快的写脚本爆破了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;typedef unsigned char sngl;struct Ele&#123; char byte; //由于最开始写的时候把byte的类型设置为unsigned char int mem1; //硬是跑出包含正确种子在内的21个种子。。。 int mem2; //无法接受.jpg&#125;;sngl aim_table[]=&#123;0x58,0x71,0x8F,0x32,0x05,0x06,0x51,0xC7,0xA7,0xF8,0x3A,0xE1,0x06,0x48,0x82,0x09,0xA1,0x12,0x9F,0x7C,0xB8,0x2A,0x6F,0x95,0xFD,0xD0,0x67,0xC8,0xE3,0xCE,0xAB,0x12,0x1F,0x98,0x6B,0x14,0xEA,0x89,0x90,0x21,0x2D,0xFD,0x9A,0xBB,0x47,0xCC,0xEA,0x9C,0xD7,0x50,0x27,0xAF,0xB9,0x77,0xDF,0xC5,0xE9,0xE1,0x50,0xD3,0x38,0x89,0xEF,0x2D,0x72,0xC2,0xDF,0xF3,0x7D,0x7D,0x65,0x95,0xED,0x13,0x00,0x1C,0xA3,0x3C,0xE3,0x57,0xE3,0xF7,0xF7,0x2C,0x73,0x88,0x34,0xB1,0x62,0xD3,0x37,0x19,0x26,0xBE,0xB2,0x33,0x20,0x3F,0x60,0x39,0x87,0xA6,0x65,0xAD,0x73,0x1A,0x6D,0x49,0x33,0x49,0xC0,0x56,0x00,0xBE,0x0A,0xCF,0x28,0x7E,0x8E,0x69,0x87,0xE1,0x05,0x88,0xDA,0x54,0x3E,0x3C,0x0E,0xA9,0xFA,0xD7,0x7F,0x4E,0x44,0xC6,0x9A,0x0A,0xD2,0x98,0x6A,0xA4,0x19,0x6D,0x8C,0xE1,0xF9,0x30,0xE5,0xFF,0x33,0x4A,0xA9,0x52,0x3A,0x0D,0x67,0x20,0x1D,0xBF,0x36,0x3E,0xE8,0x56,0xBF,0x5A,0x88,0xA8,0x69,0xD6,0xAB,0x52,0xF1,0x14,0xF2,0xD7,0xEF,0x92,0xF7,0xA0,0x70,0xA1,0xEF,0xE3,0x1F,0x66,0x2B,0x97,0xF6,0x2B,0x30,0x0F,0xB0,0xB4,0xC0,0xFE,0xA6,0x62,0xFD,0xE6,0x4C,0x39,0xCF,0x20,0xB3,0x10,0x60,0x9F,0x34,0xBE,0xB2,0x1C,0x3B,0x6B,0x1D,0xDF,0x53,0x72,0xF2,0xFA,0xB1,0x51,0x82,0x04,0x30,0x56,0x1F,0x37,0x72,0x7A,0x97,0x50,0x29,0x86,0x4A,0x09,0x3C,0x59,0xC4,0x41,0x71,0xF8,0x1A,0xD2,0x30,0x88,0x63,0xFF,0x85,0xDE,0x24,0x8C,0xC3,0x37,0x14,0xC7&#125;;Ele *check(Ele *_struct,int index)&#123; Ele *result = NULL; if(index &gt;= 0 &amp;&amp; index &lt;= 255) result = &amp;_struct[index]; else memset(result, 0 ,sizeof(result)); return result;&#125;void work(Ele *dst,int idx)&#123; Ele *result = NULL; Ele *v3 = NULL; int v4; Ele *v5 = NULL; Ele *v6 = NULL; Ele *v7 = NULL; Ele *v8 = NULL; unsigned int index; v8 = dst; index = idx; result = check(v8,idx); v7 = result; if(result) &#123; if(index &amp; 0xF) v3 = check(v8,index-0x1); else v3 = 0x0; v6 = v3; if(index + 0xF &lt;= 0x1E) result = 0x0; else result = check(v8,index - 0x10); v5 = result; if(v6 || result) &#123; if(v6) &#123; v7-&gt;mem1 = v7-&gt;byte + v6-&gt;mem1; result = v7; v7-&gt;mem2 = 2 * v6-&gt;mem2; &#125; if(v5) &#123; v4 = v5-&gt;mem1 + v7-&gt;byte; if(v4 &lt; v7-&gt;mem1) &#123; v7-&gt;mem1 = v4; result = v7; v7-&gt;mem2 = 2 * v5-&gt;mem2 | 1; &#125; &#125; &#125; else &#123; result = v7; v7-&gt;mem1 = v7-&gt;byte; &#125; &#125; return;&#125;bool calculate(sngl str[])&#123; Ele *Dst; Dst = (Ele *)malloc(sizeof(Ele)*0x100); memset(Dst,0,0xC00); for(int i = 0;i &lt;= 255 ; i++) &#123; Dst[i].byte = str[i]; Dst[i].mem1 = 0x7FFFFFFF; Dst[i].mem2 = 0; work(Dst,i); &#125; if(Dst[255].mem1 == 0x700) return true; else return false; &#125;int main()&#123; unsigned int time; int cas = 0; for(time = 0x5AFFE790 ; time &lt; 0x5B028A8F ; time ++) &#123; srand(time); sngl table[256]; memcpy(table,aim_table,256); for(int i = 0 ; i &lt;= 255 ; i++) &#123; table[i] ^= rand(); &#125; if(calculate(table)) &#123; printf(\"0x%x\",time); break; &#125; &#125; return 0;&#125; //可以得到时间是0x5B00E398 然后就在magic._time64调用完后修改返回值 然后就单步，会找到一个需要输入的函数sub_4023B1，这里用到了回调的机制，真是打开了新世界的大门 依旧ida打开 可以看到输入是26个字符，然后对输入进行加密（我修改过函数名）然后一个判断，通过了以后再对加密串进行加密（可以猜测加密是异或之类的可以两次加密复原的那种），然后分析encode，发现确实是通过异或加密的。 然后再看sub_4029C7这个判断函数（只截了一部分） 看起来贼复杂（其实做起来也很复杂。。。啊我的头发 这里用到了setjmp和longjmp，大致上算是goto的升级版 其实相当于汇编机器码一样的，ins_table里存的就相当于指令，根据指令一个个进行操作，简化以后是这样 12345unsigned char arg = 0x66;ch += 0xCC;ch &amp;= 0xFF;ch ^= arg;arg = ~ arg; 由于密文也已经知道（key_word)就可以进行爆破正确的加密后的密文了（正确的输入没必要跑，因为可以通过程序自动第二次加密得到:P 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int keyboard[]=&#123;0x89 ,0xC1 ,0xEC ,0x50 ,0x97 ,0x3A ,0x57 ,0x59 ,0xE4 ,0xE6 ,0xE4 ,0x42 ,0xCB,0xD9 ,0x08 ,0x22 ,0xAE ,0x9D ,0x7C ,0x07 ,0x80 ,0x8F ,0x1B ,0x45 ,0x04 ,0xE8&#125;;int main()&#123; char ans[26]; int arg[2] = &#123;0x66,0x99&#125;; for(int i = 0 ;i &lt; 26 ; i++) &#123; int j; int ch; for(j = 0x00;j &lt; 0xFF ; j++) &#123; ch = j; ch += 0xCC; ch &amp;= 0xFF; ch ^= arg[i%2]; if(ch == keyboard[i]) &#123; printf(\"%02x\",j); break; &#125; &#125; &#125; return 0; //238cbefd25d765f4b6b3b60fe174a2effc384ed21a4ab11096a5 &#125; 然后就在第一次加密后，将对应的内存修改为得到的字串 然后这时候就有神秘的情况出现，这是错误输入没有的 通过对比和分析机器码可以猜测，这个操作不重要，于是可以把出现除0的地方改成除1，由于除数也是机器码里的，所以直接通过修改内存就可以 然后继续步过，当再次通过加密函数的时候，可以看见内存里之前修改的部分已经变成了一半的flag。。。 然后注意控制台黑框框，继续步过 然后就能得到完整的输出 可以得到完整的flag是rctf{h@ck_For_fun_02508iO2_2iOR} 前面一部分可以通过眯眼看出来23333，像我就不一样，我取下眼镜就能直接看出来2333333 要不比划一下？ 收获这次的题目，我学到了挺多东西的，或许说是更熟练了（白学家gunna 对x64dbg这个工具用的更熟练了，毕竟调了快20个小时233333发现了之前没有用到过的操作 碰到了回调函数，知道了这种机制，以后碰到就有了方向 感受到了windows下逆向的便捷，x86dbg和ida一起用起来如有神助（然而这和我是个菜鸡有什么关系呢.jpg 学到了setjmp()和longjmp()的操作 看到了结构体在内存中的存储方式 又一次分析了模拟计算机机器码的操作，下次碰到争取不慌XD","path":"2018/07/29/magic/","date":"07-29","excerpt":""},{"title":"babyre","text":"又开始口胡了 这个题是18年SUCTF的题，我当时当然一下子就看出来放弃了，毕竟那时候比现在还要菜(现在也很菜就是了)。。。 题目在这 看题题目说的是现有一个加密后的密文和加密程序，需要得到明文 这次会长抛给这道题的时候我以为是那种把加密过程逆一下的那种加密（之前做过逆加密的题），然后看那段加密看了很久，很久，很久，妈耶完全做不出来好嘛(ノ=Д=)ノ┻━┻ 然后，会长说这不是逆加密，用爆破就好了。。。 然后，好的，我这就去试试。。。 一顿分析打开ida，熟练地按下F5 虽说之前逆加密过程的想法是错的，但至少得到了点东西，比如 这么多函数连同srand在内只有operate有用。。。看了挺久才发现233333 进入operate函数就能看到我们的加密函数了，进去看看就会发现 它是单字节加密的，所以就可以爆破，四个字节以内的都能爆破。 脚本我把out里的密文按照unsigned int 的大小分开了 12345678910111213141516171819202122232425262728293031323334353637unsigned int num[]=&#123; 0xB80C91FE,0x70573EFE,0xBEED92AE,0x7F7A8193, 0x7390C17B,0x90347C6C,0xAA7A15DF,0xAA7A15DF, 0x526BA076,0x153F1A32,0x545C15AD,0x7D8AA463, 0x526BA076,0xFBCB7AA0,0x7D8AA463,0x9C513266, 0x526BA076,0x6D7DF3E1,0xAA7A15DF,0x9C513266, 0x1EDC3864,0x9323BC07,0x7D8AA463,0xFBCB7AA0, 0x153F1A32,0x526BA076,0xF5650025,0xAA7A15DF, 0x1EDC3864,0xB13AD888,0&#125;; unsigned __int64 constant = 0x1D082C23A72BE4C1;unsigned __int64 v5;unsigned int res;for(unsigned int i=0;num[i]!=0;i++)&#123; int ans; for(ans=0x20;ans&lt;0x7f;ans++) &#123; res = ans; for(unsigned int j=0;j&lt;=0x20f;++j) &#123; v5 = constant &gt;&gt; (j &amp; 0x1f); if(j &amp; 0x20) LODWORD(v5) = HIDWORD(v5); res = (res &gt;&gt; 1) ^ (((unsigned int)v5 ^ res ^ (res &gt;&gt; 16) ^ (1551120942 &gt;&gt; (((res &gt;&gt; 1) &amp; 1) + 2 * (2 * (((v9 &gt;&gt; 20) &amp; 1) + 2 * (2 * (v9 &gt;&gt; 31) + ((v9 &gt;&gt; 26) &amp; 1))) + ((v9 &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31); &#125; if(res == num[i]) &#123; printf(\"%c\",ans); //跑完flag就出来了 break; &#125; &#125;&#125; 另外一个石乐志的做法我开始写脚本的时候，把ans循环里0x7F中把F看成跟L这类符号一样的符号了，本着化简的想法（然而我下面一行的0x1F却完全没有化简的想法），就把F删了。。。删了。。。删了。。。正当我看着跑出来的乱码迷得一比的时候，我发现，我可以把ASCII码表加密一遍啊！卧槽，我真机(shi)智！ 由之前的分析，进入加密函数之前有两次输入，第一次是输入任意字符串，第二次输入一个数seed，必须满足9&lt;n&lt;=32。然后每次只能加密30个字符。 然后就开始了快(you)乐(du)的加密，把ASCII码表从0x21开始到0x7F的可打印字符加密出来，然后一个个和密文比对，也能得出flag。 123456for(int i=0;num[i]!=0;i++) &#123; for(int j=0;j&lt;95;j++) //num储存ASCII可打印字符加密结果 if(num[i] == ans[j]) //ans储存密文 printf(\"%c\",j+33); //ASCII可打印字符（不算空格，空格是0x20)从0x21（33）开始， &#125; 总结这个题，貌似是签到题，所以并不是很复杂，我找对方向以后也就用了一个晚上的时间(当然，没找对方向的时候用了几天。。。也没做出来) 果然，reverse的题花样还是很多的，而且一道题说不定有比较简单的方式，比如这道题可以啥也不管直接加密ASCII码表然后对比2333333，当然这是事后才知道哈哈哈","path":"2018/07/09/babyre/","date":"07-09","excerpt":""},{"title":"Reverse","text":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心 题目在这 随便看看在Ubuntu里file得知是64位的文件 运行下试试 看起来就是要找到密码 废话！ 一顿分析用IDA打开 发现 密码长度为32个字符串 每4位组合成一个int类型的值 判断总共是8个方程 前四个int类型的数异或以后当成rand的种子 工具 python的z3-solver库，linux下的 脚本 前四位（a,b,c,d) 12345678910#!/usr/bin/env pythonfrom z3 import *a = Int('a')b = Int('b')c = Int('c')d = Int('d')solve(b*a-c*d == 0x24CDF2E7C953DA56, 3*c+4*d-b-2*a == 0x17B85F06, 3*a*d-c*b == 0x2E6E497E6415CF3E, 27*b+a-11*d-c == 0x95AE13337) ​ 解出来就得到密码前16位 后四位（e,f,g,h） 按照只要种子一样，得到的随机数数列也是相同的，所以很容易得到它的那些参数，但是这里我踩了个坑 这里随机数要用gdb单步出来 我开始没在Ubuntu里，在Windows下用C语言写的，然后得到的参数根本解不出来。。。 只要把前十六位解出来转换成字符串，再加上16位任意字符，凑成32位的密码，关注得到随机参数时eax的值，记录下来就是了，顺便还能检查一下前十六位有没有解错（解错会有跳转 至于为什么，其实我也不知道大概是因为系统不同吧 12345678910#!/usr/bin/env pythonfrom z3 import *e = Int('e')f = Int('f')g = Int('g')h = Int('h')solve(h*0x27+e*0x16-f-g == 0xE638C96D3, h+e+g*0x2d-f*0x2d == 0xB59F2D0CB, e*0x23+f*0x29-g-h == 0xDCFE88C6D, g*0x24+e-f-h*0xd == 0xC076D98BB) ​ 同样，跑出来就是密码后16位 密码 将32位都跑出来以后，直接转换成字符串，就能得到密码 12345int i;int sum[32]=&#123;0x61,0x6D,0x70,0x6F,0x5A,0x32,0x5A,0x6B,0x4E,0x6E,0x6B,0x31,0x4E,0x48,0x6C,0x33, 0x4E,0x54,0x63,0x30,0x4E,0x54,0x63,0x31,0x5A,0x33,0x4E,0x6F,0x61,0x47,0x46,0x47&#125;;for(i=0;i&lt;32;i++) printf(\"%c\",sum[i]); 结果然后就是激动人心的得到falg的过程了 看来没错了 总结​ 这个题讲真，虽然是很简单的那种题毕竟连我都会，但是那种激动的感觉真的没法用言语说明，就像发现新大陆的感觉，也可能是那种学了这么久能独立写出题的快乐吧","path":"2018/07/09/Reverse/","date":"07-09","excerpt":""},{"title":"Hello World","text":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的 十分感谢 codgician 大佬的无私帮助，才能顺利搭好这个blog~ %%%%%%% 就跟每个语言的初学者的第一份代码一样 Hello World！Hello world~","path":"2018/07/08/hello-world/","date":"07-08","excerpt":""}]}